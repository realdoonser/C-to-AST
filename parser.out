Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    ELSE
    GEQ
    IF
    LEQ
    RETURN
    THEN
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> include program
Rule 2     program -> external_decl program
Rule 3     program -> include
Rule 4     program -> external_decl
Rule 5     include -> INCLUDE
Rule 6     external_decl -> decl
Rule 7     decl -> type declarators ;
Rule 8     decl -> new_type_dec
Rule 9     declarators -> declarator_1 , declarators
Rule 10    declarators -> declarator_1
Rule 11    declarator_1 -> declarator_2
Rule 12    declarator_1 -> declarator_2 = initializer
Rule 13    declarator_2 -> ID
Rule 14    declarator_2 -> ID ( )
Rule 15    declarator_2 -> ID [ ]
Rule 16    initializer -> NUMBER
Rule 17    initializer -> CHR
Rule 18    initializer -> STR
Rule 19    new_type_dec -> new_type ID { new_type_params } ;
Rule 20    new_type -> STRUCT
Rule 21    new_type -> CLASS
Rule 22    new_type_params -> new_type_param new_type_params
Rule 23    new_type_params -> new_type_param
Rule 24    new_type_param -> type declarators ;
Rule 25    type -> VOID
Rule 26    type -> CHAR
Rule 27    type -> SHORT
Rule 28    type -> INT
Rule 29    type -> LONG
Rule 30    type -> FLOAT
Rule 31    type -> DOUBLE

Terminals, with rules where they appear

(                    : 14
)                    : 14
,                    : 9
;                    : 7 19 24
=                    : 12
BREAK                : 
CHAR                 : 26
CHR                  : 17
CLASS                : 21
DOUBLE               : 31
ELSE                 : 
FLOAT                : 30
GEQ                  : 
ID                   : 13 14 15 19
IF                   : 
INCLUDE              : 5
INT                  : 28
LEQ                  : 
LONG                 : 29
NUMBER               : 16
RETURN               : 
SHORT                : 27
STR                  : 18
STRUCT               : 20
THEN                 : 
VOID                 : 25
WHILE                : 
[                    : 15
]                    : 15
error                : 
{                    : 19
}                    : 19

Nonterminals, with rules where they appear

decl                 : 6
declarator_1         : 9 10
declarator_2         : 11 12
declarators          : 7 9 24
external_decl        : 2 4
include              : 1 3
initializer          : 12
new_type             : 19
new_type_dec         : 8
new_type_param       : 22 23
new_type_params      : 19 22
program              : 1 2 0
type                 : 7 24

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . include program
    (2) program -> . external_decl program
    (3) program -> . include
    (4) program -> . external_decl
    (5) include -> . INCLUDE
    (6) external_decl -> . decl
    (7) decl -> . type declarators ;
    (8) decl -> . new_type_dec
    (25) type -> . VOID
    (26) type -> . CHAR
    (27) type -> . SHORT
    (28) type -> . INT
    (29) type -> . LONG
    (30) type -> . FLOAT
    (31) type -> . DOUBLE
    (19) new_type_dec -> . new_type ID { new_type_params } ;
    (20) new_type -> . STRUCT
    (21) new_type -> . CLASS

    INCLUDE         shift and go to state 4
    VOID            shift and go to state 8
    CHAR            shift and go to state 9
    SHORT           shift and go to state 10
    INT             shift and go to state 11
    LONG            shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    STRUCT          shift and go to state 16
    CLASS           shift and go to state 17

    program                        shift and go to state 1
    include                        shift and go to state 2
    external_decl                  shift and go to state 3
    decl                           shift and go to state 5
    type                           shift and go to state 6
    new_type_dec                   shift and go to state 7
    new_type                       shift and go to state 15

state 1

    (0) S' -> program .



state 2

    (1) program -> include . program
    (3) program -> include .
    (1) program -> . include program
    (2) program -> . external_decl program
    (3) program -> . include
    (4) program -> . external_decl
    (5) include -> . INCLUDE
    (6) external_decl -> . decl
    (7) decl -> . type declarators ;
    (8) decl -> . new_type_dec
    (25) type -> . VOID
    (26) type -> . CHAR
    (27) type -> . SHORT
    (28) type -> . INT
    (29) type -> . LONG
    (30) type -> . FLOAT
    (31) type -> . DOUBLE
    (19) new_type_dec -> . new_type ID { new_type_params } ;
    (20) new_type -> . STRUCT
    (21) new_type -> . CLASS

    $end            reduce using rule 3 (program -> include .)
    INCLUDE         shift and go to state 4
    VOID            shift and go to state 8
    CHAR            shift and go to state 9
    SHORT           shift and go to state 10
    INT             shift and go to state 11
    LONG            shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    STRUCT          shift and go to state 16
    CLASS           shift and go to state 17

    include                        shift and go to state 2
    program                        shift and go to state 18
    external_decl                  shift and go to state 3
    decl                           shift and go to state 5
    type                           shift and go to state 6
    new_type_dec                   shift and go to state 7
    new_type                       shift and go to state 15

state 3

    (2) program -> external_decl . program
    (4) program -> external_decl .
    (1) program -> . include program
    (2) program -> . external_decl program
    (3) program -> . include
    (4) program -> . external_decl
    (5) include -> . INCLUDE
    (6) external_decl -> . decl
    (7) decl -> . type declarators ;
    (8) decl -> . new_type_dec
    (25) type -> . VOID
    (26) type -> . CHAR
    (27) type -> . SHORT
    (28) type -> . INT
    (29) type -> . LONG
    (30) type -> . FLOAT
    (31) type -> . DOUBLE
    (19) new_type_dec -> . new_type ID { new_type_params } ;
    (20) new_type -> . STRUCT
    (21) new_type -> . CLASS

    $end            reduce using rule 4 (program -> external_decl .)
    INCLUDE         shift and go to state 4
    VOID            shift and go to state 8
    CHAR            shift and go to state 9
    SHORT           shift and go to state 10
    INT             shift and go to state 11
    LONG            shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14
    STRUCT          shift and go to state 16
    CLASS           shift and go to state 17

    external_decl                  shift and go to state 3
    program                        shift and go to state 19
    include                        shift and go to state 2
    decl                           shift and go to state 5
    type                           shift and go to state 6
    new_type_dec                   shift and go to state 7
    new_type                       shift and go to state 15

state 4

    (5) include -> INCLUDE .

    INCLUDE         reduce using rule 5 (include -> INCLUDE .)
    VOID            reduce using rule 5 (include -> INCLUDE .)
    CHAR            reduce using rule 5 (include -> INCLUDE .)
    SHORT           reduce using rule 5 (include -> INCLUDE .)
    INT             reduce using rule 5 (include -> INCLUDE .)
    LONG            reduce using rule 5 (include -> INCLUDE .)
    FLOAT           reduce using rule 5 (include -> INCLUDE .)
    DOUBLE          reduce using rule 5 (include -> INCLUDE .)
    STRUCT          reduce using rule 5 (include -> INCLUDE .)
    CLASS           reduce using rule 5 (include -> INCLUDE .)
    $end            reduce using rule 5 (include -> INCLUDE .)


state 5

    (6) external_decl -> decl .

    INCLUDE         reduce using rule 6 (external_decl -> decl .)
    VOID            reduce using rule 6 (external_decl -> decl .)
    CHAR            reduce using rule 6 (external_decl -> decl .)
    SHORT           reduce using rule 6 (external_decl -> decl .)
    INT             reduce using rule 6 (external_decl -> decl .)
    LONG            reduce using rule 6 (external_decl -> decl .)
    FLOAT           reduce using rule 6 (external_decl -> decl .)
    DOUBLE          reduce using rule 6 (external_decl -> decl .)
    STRUCT          reduce using rule 6 (external_decl -> decl .)
    CLASS           reduce using rule 6 (external_decl -> decl .)
    $end            reduce using rule 6 (external_decl -> decl .)


state 6

    (7) decl -> type . declarators ;
    (9) declarators -> . declarator_1 , declarators
    (10) declarators -> . declarator_1
    (11) declarator_1 -> . declarator_2
    (12) declarator_1 -> . declarator_2 = initializer
    (13) declarator_2 -> . ID
    (14) declarator_2 -> . ID ( )
    (15) declarator_2 -> . ID [ ]

    ID              shift and go to state 23

    declarators                    shift and go to state 20
    declarator_1                   shift and go to state 21
    declarator_2                   shift and go to state 22

state 7

    (8) decl -> new_type_dec .

    INCLUDE         reduce using rule 8 (decl -> new_type_dec .)
    VOID            reduce using rule 8 (decl -> new_type_dec .)
    CHAR            reduce using rule 8 (decl -> new_type_dec .)
    SHORT           reduce using rule 8 (decl -> new_type_dec .)
    INT             reduce using rule 8 (decl -> new_type_dec .)
    LONG            reduce using rule 8 (decl -> new_type_dec .)
    FLOAT           reduce using rule 8 (decl -> new_type_dec .)
    DOUBLE          reduce using rule 8 (decl -> new_type_dec .)
    STRUCT          reduce using rule 8 (decl -> new_type_dec .)
    CLASS           reduce using rule 8 (decl -> new_type_dec .)
    $end            reduce using rule 8 (decl -> new_type_dec .)


state 8

    (25) type -> VOID .

    ID              reduce using rule 25 (type -> VOID .)


state 9

    (26) type -> CHAR .

    ID              reduce using rule 26 (type -> CHAR .)


state 10

    (27) type -> SHORT .

    ID              reduce using rule 27 (type -> SHORT .)


state 11

    (28) type -> INT .

    ID              reduce using rule 28 (type -> INT .)


state 12

    (29) type -> LONG .

    ID              reduce using rule 29 (type -> LONG .)


state 13

    (30) type -> FLOAT .

    ID              reduce using rule 30 (type -> FLOAT .)


state 14

    (31) type -> DOUBLE .

    ID              reduce using rule 31 (type -> DOUBLE .)


state 15

    (19) new_type_dec -> new_type . ID { new_type_params } ;

    ID              shift and go to state 24


state 16

    (20) new_type -> STRUCT .

    ID              reduce using rule 20 (new_type -> STRUCT .)


state 17

    (21) new_type -> CLASS .

    ID              reduce using rule 21 (new_type -> CLASS .)


state 18

    (1) program -> include program .

    $end            reduce using rule 1 (program -> include program .)


state 19

    (2) program -> external_decl program .

    $end            reduce using rule 2 (program -> external_decl program .)


state 20

    (7) decl -> type declarators . ;

    ;               shift and go to state 25


state 21

    (9) declarators -> declarator_1 . , declarators
    (10) declarators -> declarator_1 .

    ,               shift and go to state 26
    ;               reduce using rule 10 (declarators -> declarator_1 .)


state 22

    (11) declarator_1 -> declarator_2 .
    (12) declarator_1 -> declarator_2 . = initializer

    ,               reduce using rule 11 (declarator_1 -> declarator_2 .)
    ;               reduce using rule 11 (declarator_1 -> declarator_2 .)
    =               shift and go to state 27


state 23

    (13) declarator_2 -> ID .
    (14) declarator_2 -> ID . ( )
    (15) declarator_2 -> ID . [ ]

    =               reduce using rule 13 (declarator_2 -> ID .)
    ,               reduce using rule 13 (declarator_2 -> ID .)
    ;               reduce using rule 13 (declarator_2 -> ID .)
    (               shift and go to state 28
    [               shift and go to state 29


state 24

    (19) new_type_dec -> new_type ID . { new_type_params } ;

    {               shift and go to state 30


state 25

    (7) decl -> type declarators ; .

    INCLUDE         reduce using rule 7 (decl -> type declarators ; .)
    VOID            reduce using rule 7 (decl -> type declarators ; .)
    CHAR            reduce using rule 7 (decl -> type declarators ; .)
    SHORT           reduce using rule 7 (decl -> type declarators ; .)
    INT             reduce using rule 7 (decl -> type declarators ; .)
    LONG            reduce using rule 7 (decl -> type declarators ; .)
    FLOAT           reduce using rule 7 (decl -> type declarators ; .)
    DOUBLE          reduce using rule 7 (decl -> type declarators ; .)
    STRUCT          reduce using rule 7 (decl -> type declarators ; .)
    CLASS           reduce using rule 7 (decl -> type declarators ; .)
    $end            reduce using rule 7 (decl -> type declarators ; .)


state 26

    (9) declarators -> declarator_1 , . declarators
    (9) declarators -> . declarator_1 , declarators
    (10) declarators -> . declarator_1
    (11) declarator_1 -> . declarator_2
    (12) declarator_1 -> . declarator_2 = initializer
    (13) declarator_2 -> . ID
    (14) declarator_2 -> . ID ( )
    (15) declarator_2 -> . ID [ ]

    ID              shift and go to state 23

    declarator_1                   shift and go to state 21
    declarators                    shift and go to state 31
    declarator_2                   shift and go to state 22

state 27

    (12) declarator_1 -> declarator_2 = . initializer
    (16) initializer -> . NUMBER
    (17) initializer -> . CHR
    (18) initializer -> . STR

    NUMBER          shift and go to state 33
    CHR             shift and go to state 34
    STR             shift and go to state 35

    initializer                    shift and go to state 32

state 28

    (14) declarator_2 -> ID ( . )

    )               shift and go to state 36


state 29

    (15) declarator_2 -> ID [ . ]

    ]               shift and go to state 37


state 30

    (19) new_type_dec -> new_type ID { . new_type_params } ;
    (22) new_type_params -> . new_type_param new_type_params
    (23) new_type_params -> . new_type_param
    (24) new_type_param -> . type declarators ;
    (25) type -> . VOID
    (26) type -> . CHAR
    (27) type -> . SHORT
    (28) type -> . INT
    (29) type -> . LONG
    (30) type -> . FLOAT
    (31) type -> . DOUBLE

    VOID            shift and go to state 8
    CHAR            shift and go to state 9
    SHORT           shift and go to state 10
    INT             shift and go to state 11
    LONG            shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14

    new_type_params                shift and go to state 38
    new_type_param                 shift and go to state 39
    type                           shift and go to state 40

state 31

    (9) declarators -> declarator_1 , declarators .

    ;               reduce using rule 9 (declarators -> declarator_1 , declarators .)


state 32

    (12) declarator_1 -> declarator_2 = initializer .

    ,               reduce using rule 12 (declarator_1 -> declarator_2 = initializer .)
    ;               reduce using rule 12 (declarator_1 -> declarator_2 = initializer .)


state 33

    (16) initializer -> NUMBER .

    ,               reduce using rule 16 (initializer -> NUMBER .)
    ;               reduce using rule 16 (initializer -> NUMBER .)


state 34

    (17) initializer -> CHR .

    ,               reduce using rule 17 (initializer -> CHR .)
    ;               reduce using rule 17 (initializer -> CHR .)


state 35

    (18) initializer -> STR .

    ,               reduce using rule 18 (initializer -> STR .)
    ;               reduce using rule 18 (initializer -> STR .)


state 36

    (14) declarator_2 -> ID ( ) .

    =               reduce using rule 14 (declarator_2 -> ID ( ) .)
    ,               reduce using rule 14 (declarator_2 -> ID ( ) .)
    ;               reduce using rule 14 (declarator_2 -> ID ( ) .)


state 37

    (15) declarator_2 -> ID [ ] .

    =               reduce using rule 15 (declarator_2 -> ID [ ] .)
    ,               reduce using rule 15 (declarator_2 -> ID [ ] .)
    ;               reduce using rule 15 (declarator_2 -> ID [ ] .)


state 38

    (19) new_type_dec -> new_type ID { new_type_params . } ;

    }               shift and go to state 41


state 39

    (22) new_type_params -> new_type_param . new_type_params
    (23) new_type_params -> new_type_param .
    (22) new_type_params -> . new_type_param new_type_params
    (23) new_type_params -> . new_type_param
    (24) new_type_param -> . type declarators ;
    (25) type -> . VOID
    (26) type -> . CHAR
    (27) type -> . SHORT
    (28) type -> . INT
    (29) type -> . LONG
    (30) type -> . FLOAT
    (31) type -> . DOUBLE

    }               reduce using rule 23 (new_type_params -> new_type_param .)
    VOID            shift and go to state 8
    CHAR            shift and go to state 9
    SHORT           shift and go to state 10
    INT             shift and go to state 11
    LONG            shift and go to state 12
    FLOAT           shift and go to state 13
    DOUBLE          shift and go to state 14

    new_type_param                 shift and go to state 39
    new_type_params                shift and go to state 42
    type                           shift and go to state 40

state 40

    (24) new_type_param -> type . declarators ;
    (9) declarators -> . declarator_1 , declarators
    (10) declarators -> . declarator_1
    (11) declarator_1 -> . declarator_2
    (12) declarator_1 -> . declarator_2 = initializer
    (13) declarator_2 -> . ID
    (14) declarator_2 -> . ID ( )
    (15) declarator_2 -> . ID [ ]

    ID              shift and go to state 23

    declarators                    shift and go to state 43
    declarator_1                   shift and go to state 21
    declarator_2                   shift and go to state 22

state 41

    (19) new_type_dec -> new_type ID { new_type_params } . ;

    ;               shift and go to state 44


state 42

    (22) new_type_params -> new_type_param new_type_params .

    }               reduce using rule 22 (new_type_params -> new_type_param new_type_params .)


state 43

    (24) new_type_param -> type declarators . ;

    ;               shift and go to state 45


state 44

    (19) new_type_dec -> new_type ID { new_type_params } ; .

    INCLUDE         reduce using rule 19 (new_type_dec -> new_type ID { new_type_params } ; .)
    VOID            reduce using rule 19 (new_type_dec -> new_type ID { new_type_params } ; .)
    CHAR            reduce using rule 19 (new_type_dec -> new_type ID { new_type_params } ; .)
    SHORT           reduce using rule 19 (new_type_dec -> new_type ID { new_type_params } ; .)
    INT             reduce using rule 19 (new_type_dec -> new_type ID { new_type_params } ; .)
    LONG            reduce using rule 19 (new_type_dec -> new_type ID { new_type_params } ; .)
    FLOAT           reduce using rule 19 (new_type_dec -> new_type ID { new_type_params } ; .)
    DOUBLE          reduce using rule 19 (new_type_dec -> new_type ID { new_type_params } ; .)
    STRUCT          reduce using rule 19 (new_type_dec -> new_type ID { new_type_params } ; .)
    CLASS           reduce using rule 19 (new_type_dec -> new_type ID { new_type_params } ; .)
    $end            reduce using rule 19 (new_type_dec -> new_type ID { new_type_params } ; .)


state 45

    (24) new_type_param -> type declarators ; .

    VOID            reduce using rule 24 (new_type_param -> type declarators ; .)
    CHAR            reduce using rule 24 (new_type_param -> type declarators ; .)
    SHORT           reduce using rule 24 (new_type_param -> type declarators ; .)
    INT             reduce using rule 24 (new_type_param -> type declarators ; .)
    LONG            reduce using rule 24 (new_type_param -> type declarators ; .)
    FLOAT           reduce using rule 24 (new_type_param -> type declarators ; .)
    DOUBLE          reduce using rule 24 (new_type_param -> type declarators ; .)
    }               reduce using rule 24 (new_type_param -> type declarators ; .)

