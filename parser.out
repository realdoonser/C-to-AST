Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    CONTINUE
    GEQ
    LEQ

Grammar

Rule 0     S' -> program
Rule 1     program -> include program
Rule 2     program -> external_decl program
Rule 3     program -> include
Rule 4     program -> external_decl
Rule 5     include -> INCLUDE
Rule 6     external_decl -> decl ;
Rule 7     external_decl -> func_def
Rule 8     decl -> usual_dec
Rule 9     decl -> new_type_dec
Rule 10    usual_dec -> type declarators
Rule 11    declarators -> declarator_1 , declarators
Rule 12    declarators -> declarator_1
Rule 13    declarator_1 -> declarator_2
Rule 14    declarator_1 -> declarator_2 = initializer
Rule 15    declarator_2 -> ID
Rule 16    declarator_2 -> ID ( )
Rule 17    declarator_2 -> ID [ ]
Rule 18    declarator_2 -> ID [ expression ]
Rule 19    initializer -> expression
Rule 20    initializer -> { expressions }
Rule 21    expressions -> expression , expressions
Rule 22    expressions -> expression
Rule 23    expression -> ID
Rule 24    expression -> NUMBER
Rule 25    expression -> CHR
Rule 26    expression -> STR
Rule 27    expression -> assignment_expr
Rule 28    new_type_dec -> new_type ID { new_type_params } ;
Rule 29    new_type -> STRUCT
Rule 30    new_type -> CLASS
Rule 31    new_type_params -> new_type_param new_type_params
Rule 32    new_type_params -> new_type_param
Rule 33    new_type_param -> type declarators ;
Rule 34    func_def -> type ID ( params ) { statements }
Rule 35    func_def -> type ID ( ) { statements }
Rule 36    func_def -> type ID ( params ) { }
Rule 37    func_def -> type ID ( ) { }
Rule 38    params -> param , params
Rule 39    params -> param
Rule 40    param -> type declarator_2
Rule 41    statements -> statement statements
Rule 42    statements -> statement
Rule 43    statement -> expression ;
Rule 44    statement -> decl ;
Rule 45    statement -> conditional
Rule 46    statement -> iteration
Rule 47    statement -> jump ;
Rule 48    statement -> ;
Rule 49    conditional -> IF ( expression ) { stats_or_null }
Rule 50    conditional -> IF ( expression ) { stats_or_null } ELSE conditional
Rule 51    conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null }
Rule 52    statement -> { stats_or_null }
Rule 53    stats_or_null -> statements
Rule 54    stats_or_null -> empty
Rule 55    iteration -> WHILE ( expression ) { stats_or_null }
Rule 56    iteration -> DO { stats_or_null } WHILE ( expression ) ;
Rule 57    iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null }
Rule 58    expr_or_null -> expression
Rule 59    expr_or_null -> empty
Rule 60    expr_or_null_or_init -> expr_or_null
Rule 61    expr_or_null_or_init -> usual_dec
Rule 62    assignment_expr -> ID assignmenteq_op expression
Rule 63    assignmenteq_op -> =
Rule 64    assignmenteq_op -> MULTEQ
Rule 65    assignmenteq_op -> ADDEQ
Rule 66    assignmenteq_op -> SUBEQ
Rule 67    assignmenteq_op -> MODEQ
Rule 68    assignmenteq_op -> DIVEQ
Rule 69    jump -> RETURN expression
Rule 70    type -> VOID
Rule 71    type -> CHAR
Rule 72    type -> SHORT
Rule 73    type -> INT
Rule 74    type -> LONG
Rule 75    type -> FLOAT
Rule 76    type -> DOUBLE
Rule 77    empty -> <empty>

Terminals, with rules where they appear

(                    : 16 34 35 36 37 49 50 51 55 56 57
)                    : 16 34 35 36 37 49 50 51 55 56 57
,                    : 11 21 38
;                    : 6 28 33 43 44 47 48 56 57 57
=                    : 14 63
ADDEQ                : 65
BREAK                : 
CHAR                 : 71
CHR                  : 25
CLASS                : 30
CONTINUE             : 
DIVEQ                : 68
DO                   : 56
DOUBLE               : 76
ELSE                 : 50 51
FLOAT                : 75
FOR                  : 57
GEQ                  : 
ID                   : 15 16 17 18 23 28 34 35 36 37 62
IF                   : 49 50 51
INCLUDE              : 5
INT                  : 73
LEQ                  : 
LONG                 : 74
MODEQ                : 67
MULTEQ               : 64
NUMBER               : 24
RETURN               : 69
SHORT                : 72
STR                  : 26
STRUCT               : 29
SUBEQ                : 66
VOID                 : 70
WHILE                : 55 56
[                    : 17 18
]                    : 17 18
error                : 
{                    : 20 28 34 35 36 37 49 50 51 51 52 55 56 57
}                    : 20 28 34 35 36 37 49 50 51 51 52 55 56 57

Nonterminals, with rules where they appear

assignment_expr      : 27
assignmenteq_op      : 62
conditional          : 45 50
decl                 : 6 44
declarator_1         : 11 12
declarator_2         : 13 14 40
declarators          : 10 11 33
empty                : 54 59
expr_or_null         : 57 57 60
expr_or_null_or_init : 57
expression           : 18 19 21 22 43 49 50 51 55 56 58 62 69
expressions          : 20 21
external_decl        : 2 4
func_def             : 7
include              : 1 3
initializer          : 14
iteration            : 46
jump                 : 47
new_type             : 28
new_type_dec         : 9
new_type_param       : 31 32
new_type_params      : 28 31
param                : 38 39
params               : 34 36 38
program              : 1 2 0
statement            : 41 42
statements           : 34 35 41 53
stats_or_null        : 49 50 51 51 52 55 56 57
type                 : 10 33 34 35 36 37 40
usual_dec            : 8 61

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . include program
    (2) program -> . external_decl program
    (3) program -> . include
    (4) program -> . external_decl
    (5) include -> . INCLUDE
    (6) external_decl -> . decl ;
    (7) external_decl -> . func_def
    (8) decl -> . usual_dec
    (9) decl -> . new_type_dec
    (34) func_def -> . type ID ( params ) { statements }
    (35) func_def -> . type ID ( ) { statements }
    (36) func_def -> . type ID ( params ) { }
    (37) func_def -> . type ID ( ) { }
    (10) usual_dec -> . type declarators
    (28) new_type_dec -> . new_type ID { new_type_params } ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (29) new_type -> . STRUCT
    (30) new_type -> . CLASS

    INCLUDE         shift and go to state 4
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17
    STRUCT          shift and go to state 18
    CLASS           shift and go to state 19

    program                        shift and go to state 1
    include                        shift and go to state 2
    external_decl                  shift and go to state 3
    decl                           shift and go to state 5
    func_def                       shift and go to state 6
    usual_dec                      shift and go to state 7
    new_type_dec                   shift and go to state 8
    type                           shift and go to state 9
    new_type                       shift and go to state 10

state 1

    (0) S' -> program .



state 2

    (1) program -> include . program
    (3) program -> include .
    (1) program -> . include program
    (2) program -> . external_decl program
    (3) program -> . include
    (4) program -> . external_decl
    (5) include -> . INCLUDE
    (6) external_decl -> . decl ;
    (7) external_decl -> . func_def
    (8) decl -> . usual_dec
    (9) decl -> . new_type_dec
    (34) func_def -> . type ID ( params ) { statements }
    (35) func_def -> . type ID ( ) { statements }
    (36) func_def -> . type ID ( params ) { }
    (37) func_def -> . type ID ( ) { }
    (10) usual_dec -> . type declarators
    (28) new_type_dec -> . new_type ID { new_type_params } ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (29) new_type -> . STRUCT
    (30) new_type -> . CLASS

    $end            reduce using rule 3 (program -> include .)
    INCLUDE         shift and go to state 4
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17
    STRUCT          shift and go to state 18
    CLASS           shift and go to state 19

    include                        shift and go to state 2
    program                        shift and go to state 20
    external_decl                  shift and go to state 3
    decl                           shift and go to state 5
    func_def                       shift and go to state 6
    usual_dec                      shift and go to state 7
    new_type_dec                   shift and go to state 8
    type                           shift and go to state 9
    new_type                       shift and go to state 10

state 3

    (2) program -> external_decl . program
    (4) program -> external_decl .
    (1) program -> . include program
    (2) program -> . external_decl program
    (3) program -> . include
    (4) program -> . external_decl
    (5) include -> . INCLUDE
    (6) external_decl -> . decl ;
    (7) external_decl -> . func_def
    (8) decl -> . usual_dec
    (9) decl -> . new_type_dec
    (34) func_def -> . type ID ( params ) { statements }
    (35) func_def -> . type ID ( ) { statements }
    (36) func_def -> . type ID ( params ) { }
    (37) func_def -> . type ID ( ) { }
    (10) usual_dec -> . type declarators
    (28) new_type_dec -> . new_type ID { new_type_params } ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (29) new_type -> . STRUCT
    (30) new_type -> . CLASS

    $end            reduce using rule 4 (program -> external_decl .)
    INCLUDE         shift and go to state 4
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17
    STRUCT          shift and go to state 18
    CLASS           shift and go to state 19

    external_decl                  shift and go to state 3
    program                        shift and go to state 21
    include                        shift and go to state 2
    decl                           shift and go to state 5
    func_def                       shift and go to state 6
    usual_dec                      shift and go to state 7
    new_type_dec                   shift and go to state 8
    type                           shift and go to state 9
    new_type                       shift and go to state 10

state 4

    (5) include -> INCLUDE .

    INCLUDE         reduce using rule 5 (include -> INCLUDE .)
    VOID            reduce using rule 5 (include -> INCLUDE .)
    CHAR            reduce using rule 5 (include -> INCLUDE .)
    SHORT           reduce using rule 5 (include -> INCLUDE .)
    INT             reduce using rule 5 (include -> INCLUDE .)
    LONG            reduce using rule 5 (include -> INCLUDE .)
    FLOAT           reduce using rule 5 (include -> INCLUDE .)
    DOUBLE          reduce using rule 5 (include -> INCLUDE .)
    STRUCT          reduce using rule 5 (include -> INCLUDE .)
    CLASS           reduce using rule 5 (include -> INCLUDE .)
    $end            reduce using rule 5 (include -> INCLUDE .)


state 5

    (6) external_decl -> decl . ;

    ;               shift and go to state 22


state 6

    (7) external_decl -> func_def .

    INCLUDE         reduce using rule 7 (external_decl -> func_def .)
    VOID            reduce using rule 7 (external_decl -> func_def .)
    CHAR            reduce using rule 7 (external_decl -> func_def .)
    SHORT           reduce using rule 7 (external_decl -> func_def .)
    INT             reduce using rule 7 (external_decl -> func_def .)
    LONG            reduce using rule 7 (external_decl -> func_def .)
    FLOAT           reduce using rule 7 (external_decl -> func_def .)
    DOUBLE          reduce using rule 7 (external_decl -> func_def .)
    STRUCT          reduce using rule 7 (external_decl -> func_def .)
    CLASS           reduce using rule 7 (external_decl -> func_def .)
    $end            reduce using rule 7 (external_decl -> func_def .)


state 7

    (8) decl -> usual_dec .

    ;               reduce using rule 8 (decl -> usual_dec .)


state 8

    (9) decl -> new_type_dec .

    ;               reduce using rule 9 (decl -> new_type_dec .)


state 9

    (34) func_def -> type . ID ( params ) { statements }
    (35) func_def -> type . ID ( ) { statements }
    (36) func_def -> type . ID ( params ) { }
    (37) func_def -> type . ID ( ) { }
    (10) usual_dec -> type . declarators
    (11) declarators -> . declarator_1 , declarators
    (12) declarators -> . declarator_1
    (13) declarator_1 -> . declarator_2
    (14) declarator_1 -> . declarator_2 = initializer
    (15) declarator_2 -> . ID
    (16) declarator_2 -> . ID ( )
    (17) declarator_2 -> . ID [ ]
    (18) declarator_2 -> . ID [ expression ]

    ID              shift and go to state 23

    declarators                    shift and go to state 24
    declarator_1                   shift and go to state 25
    declarator_2                   shift and go to state 26

state 10

    (28) new_type_dec -> new_type . ID { new_type_params } ;

    ID              shift and go to state 27


state 11

    (70) type -> VOID .

    ID              reduce using rule 70 (type -> VOID .)


state 12

    (71) type -> CHAR .

    ID              reduce using rule 71 (type -> CHAR .)


state 13

    (72) type -> SHORT .

    ID              reduce using rule 72 (type -> SHORT .)


state 14

    (73) type -> INT .

    ID              reduce using rule 73 (type -> INT .)


state 15

    (74) type -> LONG .

    ID              reduce using rule 74 (type -> LONG .)


state 16

    (75) type -> FLOAT .

    ID              reduce using rule 75 (type -> FLOAT .)


state 17

    (76) type -> DOUBLE .

    ID              reduce using rule 76 (type -> DOUBLE .)


state 18

    (29) new_type -> STRUCT .

    ID              reduce using rule 29 (new_type -> STRUCT .)


state 19

    (30) new_type -> CLASS .

    ID              reduce using rule 30 (new_type -> CLASS .)


state 20

    (1) program -> include program .

    $end            reduce using rule 1 (program -> include program .)


state 21

    (2) program -> external_decl program .

    $end            reduce using rule 2 (program -> external_decl program .)


state 22

    (6) external_decl -> decl ; .

    INCLUDE         reduce using rule 6 (external_decl -> decl ; .)
    VOID            reduce using rule 6 (external_decl -> decl ; .)
    CHAR            reduce using rule 6 (external_decl -> decl ; .)
    SHORT           reduce using rule 6 (external_decl -> decl ; .)
    INT             reduce using rule 6 (external_decl -> decl ; .)
    LONG            reduce using rule 6 (external_decl -> decl ; .)
    FLOAT           reduce using rule 6 (external_decl -> decl ; .)
    DOUBLE          reduce using rule 6 (external_decl -> decl ; .)
    STRUCT          reduce using rule 6 (external_decl -> decl ; .)
    CLASS           reduce using rule 6 (external_decl -> decl ; .)
    $end            reduce using rule 6 (external_decl -> decl ; .)


state 23

    (34) func_def -> type ID . ( params ) { statements }
    (35) func_def -> type ID . ( ) { statements }
    (36) func_def -> type ID . ( params ) { }
    (37) func_def -> type ID . ( ) { }
    (15) declarator_2 -> ID .
    (16) declarator_2 -> ID . ( )
    (17) declarator_2 -> ID . [ ]
    (18) declarator_2 -> ID . [ expression ]

    (               shift and go to state 28
    =               reduce using rule 15 (declarator_2 -> ID .)
    ,               reduce using rule 15 (declarator_2 -> ID .)
    ;               reduce using rule 15 (declarator_2 -> ID .)
    [               shift and go to state 29


state 24

    (10) usual_dec -> type declarators .

    ;               reduce using rule 10 (usual_dec -> type declarators .)


state 25

    (11) declarators -> declarator_1 . , declarators
    (12) declarators -> declarator_1 .

    ,               shift and go to state 30
    ;               reduce using rule 12 (declarators -> declarator_1 .)


state 26

    (13) declarator_1 -> declarator_2 .
    (14) declarator_1 -> declarator_2 . = initializer

    ,               reduce using rule 13 (declarator_1 -> declarator_2 .)
    ;               reduce using rule 13 (declarator_1 -> declarator_2 .)
    =               shift and go to state 31


state 27

    (28) new_type_dec -> new_type ID . { new_type_params } ;

    {               shift and go to state 32


state 28

    (34) func_def -> type ID ( . params ) { statements }
    (35) func_def -> type ID ( . ) { statements }
    (36) func_def -> type ID ( . params ) { }
    (37) func_def -> type ID ( . ) { }
    (16) declarator_2 -> ID ( . )
    (38) params -> . param , params
    (39) params -> . param
    (40) param -> . type declarator_2
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE

    )               shift and go to state 35
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17

    type                           shift and go to state 33
    params                         shift and go to state 34
    param                          shift and go to state 36

state 29

    (17) declarator_2 -> ID [ . ]
    (18) declarator_2 -> ID [ . expression ]
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (62) assignment_expr -> . ID assignmenteq_op expression

    ]               shift and go to state 38
    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42

    expression                     shift and go to state 39
    assignment_expr                shift and go to state 43

state 30

    (11) declarators -> declarator_1 , . declarators
    (11) declarators -> . declarator_1 , declarators
    (12) declarators -> . declarator_1
    (13) declarator_1 -> . declarator_2
    (14) declarator_1 -> . declarator_2 = initializer
    (15) declarator_2 -> . ID
    (16) declarator_2 -> . ID ( )
    (17) declarator_2 -> . ID [ ]
    (18) declarator_2 -> . ID [ expression ]

    ID              shift and go to state 45

    declarator_1                   shift and go to state 25
    declarators                    shift and go to state 44
    declarator_2                   shift and go to state 26

state 31

    (14) declarator_1 -> declarator_2 = . initializer
    (19) initializer -> . expression
    (20) initializer -> . { expressions }
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (62) assignment_expr -> . ID assignmenteq_op expression

    {               shift and go to state 48
    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42

    initializer                    shift and go to state 46
    expression                     shift and go to state 47
    assignment_expr                shift and go to state 43

state 32

    (28) new_type_dec -> new_type ID { . new_type_params } ;
    (31) new_type_params -> . new_type_param new_type_params
    (32) new_type_params -> . new_type_param
    (33) new_type_param -> . type declarators ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE

    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17

    new_type_params                shift and go to state 49
    new_type_param                 shift and go to state 50
    type                           shift and go to state 51

state 33

    (40) param -> type . declarator_2
    (15) declarator_2 -> . ID
    (16) declarator_2 -> . ID ( )
    (17) declarator_2 -> . ID [ ]
    (18) declarator_2 -> . ID [ expression ]

    ID              shift and go to state 45

    declarator_2                   shift and go to state 52

state 34

    (34) func_def -> type ID ( params . ) { statements }
    (36) func_def -> type ID ( params . ) { }

    )               shift and go to state 53


state 35

    (35) func_def -> type ID ( ) . { statements }
    (37) func_def -> type ID ( ) . { }
    (16) declarator_2 -> ID ( ) .

    {               shift and go to state 54
    =               reduce using rule 16 (declarator_2 -> ID ( ) .)
    ,               reduce using rule 16 (declarator_2 -> ID ( ) .)
    ;               reduce using rule 16 (declarator_2 -> ID ( ) .)


state 36

    (38) params -> param . , params
    (39) params -> param .

    ,               shift and go to state 55
    )               reduce using rule 39 (params -> param .)


state 37

    (23) expression -> ID .
    (62) assignment_expr -> ID . assignmenteq_op expression
    (63) assignmenteq_op -> . =
    (64) assignmenteq_op -> . MULTEQ
    (65) assignmenteq_op -> . ADDEQ
    (66) assignmenteq_op -> . SUBEQ
    (67) assignmenteq_op -> . MODEQ
    (68) assignmenteq_op -> . DIVEQ

    ]               reduce using rule 23 (expression -> ID .)
    ,               reduce using rule 23 (expression -> ID .)
    ;               reduce using rule 23 (expression -> ID .)
    }               reduce using rule 23 (expression -> ID .)
    )               reduce using rule 23 (expression -> ID .)
    =               shift and go to state 57
    MULTEQ          shift and go to state 58
    ADDEQ           shift and go to state 59
    SUBEQ           shift and go to state 60
    MODEQ           shift and go to state 61
    DIVEQ           shift and go to state 62

    assignmenteq_op                shift and go to state 56

state 38

    (17) declarator_2 -> ID [ ] .

    =               reduce using rule 17 (declarator_2 -> ID [ ] .)
    ,               reduce using rule 17 (declarator_2 -> ID [ ] .)
    ;               reduce using rule 17 (declarator_2 -> ID [ ] .)
    )               reduce using rule 17 (declarator_2 -> ID [ ] .)


state 39

    (18) declarator_2 -> ID [ expression . ]

    ]               shift and go to state 63


state 40

    (24) expression -> NUMBER .

    ]               reduce using rule 24 (expression -> NUMBER .)
    ,               reduce using rule 24 (expression -> NUMBER .)
    ;               reduce using rule 24 (expression -> NUMBER .)
    }               reduce using rule 24 (expression -> NUMBER .)
    )               reduce using rule 24 (expression -> NUMBER .)


state 41

    (25) expression -> CHR .

    ]               reduce using rule 25 (expression -> CHR .)
    ,               reduce using rule 25 (expression -> CHR .)
    ;               reduce using rule 25 (expression -> CHR .)
    }               reduce using rule 25 (expression -> CHR .)
    )               reduce using rule 25 (expression -> CHR .)


state 42

    (26) expression -> STR .

    ]               reduce using rule 26 (expression -> STR .)
    ,               reduce using rule 26 (expression -> STR .)
    ;               reduce using rule 26 (expression -> STR .)
    }               reduce using rule 26 (expression -> STR .)
    )               reduce using rule 26 (expression -> STR .)


state 43

    (27) expression -> assignment_expr .

    ]               reduce using rule 27 (expression -> assignment_expr .)
    ,               reduce using rule 27 (expression -> assignment_expr .)
    ;               reduce using rule 27 (expression -> assignment_expr .)
    }               reduce using rule 27 (expression -> assignment_expr .)
    )               reduce using rule 27 (expression -> assignment_expr .)


state 44

    (11) declarators -> declarator_1 , declarators .

    ;               reduce using rule 11 (declarators -> declarator_1 , declarators .)


state 45

    (15) declarator_2 -> ID .
    (16) declarator_2 -> ID . ( )
    (17) declarator_2 -> ID . [ ]
    (18) declarator_2 -> ID . [ expression ]

    =               reduce using rule 15 (declarator_2 -> ID .)
    ,               reduce using rule 15 (declarator_2 -> ID .)
    ;               reduce using rule 15 (declarator_2 -> ID .)
    )               reduce using rule 15 (declarator_2 -> ID .)
    (               shift and go to state 64
    [               shift and go to state 29


state 46

    (14) declarator_1 -> declarator_2 = initializer .

    ,               reduce using rule 14 (declarator_1 -> declarator_2 = initializer .)
    ;               reduce using rule 14 (declarator_1 -> declarator_2 = initializer .)


state 47

    (19) initializer -> expression .

    ,               reduce using rule 19 (initializer -> expression .)
    ;               reduce using rule 19 (initializer -> expression .)


state 48

    (20) initializer -> { . expressions }
    (21) expressions -> . expression , expressions
    (22) expressions -> . expression
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (62) assignment_expr -> . ID assignmenteq_op expression

    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42

    expressions                    shift and go to state 65
    expression                     shift and go to state 66
    assignment_expr                shift and go to state 43

state 49

    (28) new_type_dec -> new_type ID { new_type_params . } ;

    }               shift and go to state 67


state 50

    (31) new_type_params -> new_type_param . new_type_params
    (32) new_type_params -> new_type_param .
    (31) new_type_params -> . new_type_param new_type_params
    (32) new_type_params -> . new_type_param
    (33) new_type_param -> . type declarators ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE

    }               reduce using rule 32 (new_type_params -> new_type_param .)
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17

    new_type_param                 shift and go to state 50
    new_type_params                shift and go to state 68
    type                           shift and go to state 51

state 51

    (33) new_type_param -> type . declarators ;
    (11) declarators -> . declarator_1 , declarators
    (12) declarators -> . declarator_1
    (13) declarator_1 -> . declarator_2
    (14) declarator_1 -> . declarator_2 = initializer
    (15) declarator_2 -> . ID
    (16) declarator_2 -> . ID ( )
    (17) declarator_2 -> . ID [ ]
    (18) declarator_2 -> . ID [ expression ]

    ID              shift and go to state 45

    declarators                    shift and go to state 69
    declarator_1                   shift and go to state 25
    declarator_2                   shift and go to state 26

state 52

    (40) param -> type declarator_2 .

    ,               reduce using rule 40 (param -> type declarator_2 .)
    )               reduce using rule 40 (param -> type declarator_2 .)


state 53

    (34) func_def -> type ID ( params ) . { statements }
    (36) func_def -> type ID ( params ) . { }

    {               shift and go to state 70


state 54

    (35) func_def -> type ID ( ) { . statements }
    (37) func_def -> type ID ( ) { . }
    (41) statements -> . statement statements
    (42) statements -> . statement
    (43) statement -> . expression ;
    (44) statement -> . decl ;
    (45) statement -> . conditional
    (46) statement -> . iteration
    (47) statement -> . jump ;
    (48) statement -> . ;
    (52) statement -> . { stats_or_null }
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (8) decl -> . usual_dec
    (9) decl -> . new_type_dec
    (49) conditional -> . IF ( expression ) { stats_or_null }
    (50) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (51) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (55) iteration -> . WHILE ( expression ) { stats_or_null }
    (56) iteration -> . DO { stats_or_null } WHILE ( expression ) ;
    (57) iteration -> . FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null }
    (69) jump -> . RETURN expression
    (62) assignment_expr -> . ID assignmenteq_op expression
    (10) usual_dec -> . type declarators
    (28) new_type_dec -> . new_type ID { new_type_params } ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (29) new_type -> . STRUCT
    (30) new_type -> . CLASS

    }               shift and go to state 74
    ;               shift and go to state 77
    {               shift and go to state 72
    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42
    IF              shift and go to state 82
    WHILE           shift and go to state 83
    DO              shift and go to state 84
    FOR             shift and go to state 85
    RETURN          shift and go to state 86
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17
    STRUCT          shift and go to state 18
    CLASS           shift and go to state 19

    type                           shift and go to state 71
    statements                     shift and go to state 73
    statement                      shift and go to state 75
    expression                     shift and go to state 76
    decl                           shift and go to state 78
    conditional                    shift and go to state 79
    iteration                      shift and go to state 80
    jump                           shift and go to state 81
    assignment_expr                shift and go to state 43
    usual_dec                      shift and go to state 7
    new_type_dec                   shift and go to state 8
    new_type                       shift and go to state 10

state 55

    (38) params -> param , . params
    (38) params -> . param , params
    (39) params -> . param
    (40) param -> . type declarator_2
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE

    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17

    param                          shift and go to state 36
    params                         shift and go to state 87
    type                           shift and go to state 33

state 56

    (62) assignment_expr -> ID assignmenteq_op . expression
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (62) assignment_expr -> . ID assignmenteq_op expression

    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42

    expression                     shift and go to state 88
    assignment_expr                shift and go to state 43

state 57

    (63) assignmenteq_op -> = .

    ID              reduce using rule 63 (assignmenteq_op -> = .)
    NUMBER          reduce using rule 63 (assignmenteq_op -> = .)
    CHR             reduce using rule 63 (assignmenteq_op -> = .)
    STR             reduce using rule 63 (assignmenteq_op -> = .)


state 58

    (64) assignmenteq_op -> MULTEQ .

    ID              reduce using rule 64 (assignmenteq_op -> MULTEQ .)
    NUMBER          reduce using rule 64 (assignmenteq_op -> MULTEQ .)
    CHR             reduce using rule 64 (assignmenteq_op -> MULTEQ .)
    STR             reduce using rule 64 (assignmenteq_op -> MULTEQ .)


state 59

    (65) assignmenteq_op -> ADDEQ .

    ID              reduce using rule 65 (assignmenteq_op -> ADDEQ .)
    NUMBER          reduce using rule 65 (assignmenteq_op -> ADDEQ .)
    CHR             reduce using rule 65 (assignmenteq_op -> ADDEQ .)
    STR             reduce using rule 65 (assignmenteq_op -> ADDEQ .)


state 60

    (66) assignmenteq_op -> SUBEQ .

    ID              reduce using rule 66 (assignmenteq_op -> SUBEQ .)
    NUMBER          reduce using rule 66 (assignmenteq_op -> SUBEQ .)
    CHR             reduce using rule 66 (assignmenteq_op -> SUBEQ .)
    STR             reduce using rule 66 (assignmenteq_op -> SUBEQ .)


state 61

    (67) assignmenteq_op -> MODEQ .

    ID              reduce using rule 67 (assignmenteq_op -> MODEQ .)
    NUMBER          reduce using rule 67 (assignmenteq_op -> MODEQ .)
    CHR             reduce using rule 67 (assignmenteq_op -> MODEQ .)
    STR             reduce using rule 67 (assignmenteq_op -> MODEQ .)


state 62

    (68) assignmenteq_op -> DIVEQ .

    ID              reduce using rule 68 (assignmenteq_op -> DIVEQ .)
    NUMBER          reduce using rule 68 (assignmenteq_op -> DIVEQ .)
    CHR             reduce using rule 68 (assignmenteq_op -> DIVEQ .)
    STR             reduce using rule 68 (assignmenteq_op -> DIVEQ .)


state 63

    (18) declarator_2 -> ID [ expression ] .

    =               reduce using rule 18 (declarator_2 -> ID [ expression ] .)
    ,               reduce using rule 18 (declarator_2 -> ID [ expression ] .)
    ;               reduce using rule 18 (declarator_2 -> ID [ expression ] .)
    )               reduce using rule 18 (declarator_2 -> ID [ expression ] .)


state 64

    (16) declarator_2 -> ID ( . )

    )               shift and go to state 89


state 65

    (20) initializer -> { expressions . }

    }               shift and go to state 90


state 66

    (21) expressions -> expression . , expressions
    (22) expressions -> expression .

    ,               shift and go to state 91
    }               reduce using rule 22 (expressions -> expression .)


state 67

    (28) new_type_dec -> new_type ID { new_type_params } . ;

    ;               shift and go to state 92


state 68

    (31) new_type_params -> new_type_param new_type_params .

    }               reduce using rule 31 (new_type_params -> new_type_param new_type_params .)


state 69

    (33) new_type_param -> type declarators . ;

    ;               shift and go to state 93


state 70

    (34) func_def -> type ID ( params ) { . statements }
    (36) func_def -> type ID ( params ) { . }
    (41) statements -> . statement statements
    (42) statements -> . statement
    (43) statement -> . expression ;
    (44) statement -> . decl ;
    (45) statement -> . conditional
    (46) statement -> . iteration
    (47) statement -> . jump ;
    (48) statement -> . ;
    (52) statement -> . { stats_or_null }
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (8) decl -> . usual_dec
    (9) decl -> . new_type_dec
    (49) conditional -> . IF ( expression ) { stats_or_null }
    (50) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (51) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (55) iteration -> . WHILE ( expression ) { stats_or_null }
    (56) iteration -> . DO { stats_or_null } WHILE ( expression ) ;
    (57) iteration -> . FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null }
    (69) jump -> . RETURN expression
    (62) assignment_expr -> . ID assignmenteq_op expression
    (10) usual_dec -> . type declarators
    (28) new_type_dec -> . new_type ID { new_type_params } ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (29) new_type -> . STRUCT
    (30) new_type -> . CLASS

    }               shift and go to state 95
    ;               shift and go to state 77
    {               shift and go to state 72
    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42
    IF              shift and go to state 82
    WHILE           shift and go to state 83
    DO              shift and go to state 84
    FOR             shift and go to state 85
    RETURN          shift and go to state 86
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17
    STRUCT          shift and go to state 18
    CLASS           shift and go to state 19

    type                           shift and go to state 71
    statements                     shift and go to state 94
    statement                      shift and go to state 75
    expression                     shift and go to state 76
    decl                           shift and go to state 78
    conditional                    shift and go to state 79
    iteration                      shift and go to state 80
    jump                           shift and go to state 81
    assignment_expr                shift and go to state 43
    usual_dec                      shift and go to state 7
    new_type_dec                   shift and go to state 8
    new_type                       shift and go to state 10

state 71

    (10) usual_dec -> type . declarators
    (11) declarators -> . declarator_1 , declarators
    (12) declarators -> . declarator_1
    (13) declarator_1 -> . declarator_2
    (14) declarator_1 -> . declarator_2 = initializer
    (15) declarator_2 -> . ID
    (16) declarator_2 -> . ID ( )
    (17) declarator_2 -> . ID [ ]
    (18) declarator_2 -> . ID [ expression ]

    ID              shift and go to state 45

    declarators                    shift and go to state 24
    declarator_1                   shift and go to state 25
    declarator_2                   shift and go to state 26

state 72

    (52) statement -> { . stats_or_null }
    (53) stats_or_null -> . statements
    (54) stats_or_null -> . empty
    (41) statements -> . statement statements
    (42) statements -> . statement
    (77) empty -> .
    (43) statement -> . expression ;
    (44) statement -> . decl ;
    (45) statement -> . conditional
    (46) statement -> . iteration
    (47) statement -> . jump ;
    (48) statement -> . ;
    (52) statement -> . { stats_or_null }
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (8) decl -> . usual_dec
    (9) decl -> . new_type_dec
    (49) conditional -> . IF ( expression ) { stats_or_null }
    (50) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (51) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (55) iteration -> . WHILE ( expression ) { stats_or_null }
    (56) iteration -> . DO { stats_or_null } WHILE ( expression ) ;
    (57) iteration -> . FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null }
    (69) jump -> . RETURN expression
    (62) assignment_expr -> . ID assignmenteq_op expression
    (10) usual_dec -> . type declarators
    (28) new_type_dec -> . new_type ID { new_type_params } ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (29) new_type -> . STRUCT
    (30) new_type -> . CLASS

    }               reduce using rule 77 (empty -> .)
    ;               shift and go to state 77
    {               shift and go to state 72
    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42
    IF              shift and go to state 82
    WHILE           shift and go to state 83
    DO              shift and go to state 84
    FOR             shift and go to state 85
    RETURN          shift and go to state 86
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17
    STRUCT          shift and go to state 18
    CLASS           shift and go to state 19

    stats_or_null                  shift and go to state 96
    statements                     shift and go to state 97
    empty                          shift and go to state 98
    statement                      shift and go to state 75
    expression                     shift and go to state 76
    decl                           shift and go to state 78
    conditional                    shift and go to state 79
    iteration                      shift and go to state 80
    jump                           shift and go to state 81
    assignment_expr                shift and go to state 43
    usual_dec                      shift and go to state 7
    new_type_dec                   shift and go to state 8
    type                           shift and go to state 71
    new_type                       shift and go to state 10

state 73

    (35) func_def -> type ID ( ) { statements . }

    }               shift and go to state 99


state 74

    (37) func_def -> type ID ( ) { } .

    INCLUDE         reduce using rule 37 (func_def -> type ID ( ) { } .)
    VOID            reduce using rule 37 (func_def -> type ID ( ) { } .)
    CHAR            reduce using rule 37 (func_def -> type ID ( ) { } .)
    SHORT           reduce using rule 37 (func_def -> type ID ( ) { } .)
    INT             reduce using rule 37 (func_def -> type ID ( ) { } .)
    LONG            reduce using rule 37 (func_def -> type ID ( ) { } .)
    FLOAT           reduce using rule 37 (func_def -> type ID ( ) { } .)
    DOUBLE          reduce using rule 37 (func_def -> type ID ( ) { } .)
    STRUCT          reduce using rule 37 (func_def -> type ID ( ) { } .)
    CLASS           reduce using rule 37 (func_def -> type ID ( ) { } .)
    $end            reduce using rule 37 (func_def -> type ID ( ) { } .)


state 75

    (41) statements -> statement . statements
    (42) statements -> statement .
    (41) statements -> . statement statements
    (42) statements -> . statement
    (43) statement -> . expression ;
    (44) statement -> . decl ;
    (45) statement -> . conditional
    (46) statement -> . iteration
    (47) statement -> . jump ;
    (48) statement -> . ;
    (52) statement -> . { stats_or_null }
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (8) decl -> . usual_dec
    (9) decl -> . new_type_dec
    (49) conditional -> . IF ( expression ) { stats_or_null }
    (50) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (51) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (55) iteration -> . WHILE ( expression ) { stats_or_null }
    (56) iteration -> . DO { stats_or_null } WHILE ( expression ) ;
    (57) iteration -> . FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null }
    (69) jump -> . RETURN expression
    (62) assignment_expr -> . ID assignmenteq_op expression
    (10) usual_dec -> . type declarators
    (28) new_type_dec -> . new_type ID { new_type_params } ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (29) new_type -> . STRUCT
    (30) new_type -> . CLASS

    }               reduce using rule 42 (statements -> statement .)
    ;               shift and go to state 77
    {               shift and go to state 72
    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42
    IF              shift and go to state 82
    WHILE           shift and go to state 83
    DO              shift and go to state 84
    FOR             shift and go to state 85
    RETURN          shift and go to state 86
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17
    STRUCT          shift and go to state 18
    CLASS           shift and go to state 19

    statement                      shift and go to state 75
    statements                     shift and go to state 100
    expression                     shift and go to state 76
    decl                           shift and go to state 78
    conditional                    shift and go to state 79
    iteration                      shift and go to state 80
    jump                           shift and go to state 81
    assignment_expr                shift and go to state 43
    usual_dec                      shift and go to state 7
    new_type_dec                   shift and go to state 8
    type                           shift and go to state 71
    new_type                       shift and go to state 10

state 76

    (43) statement -> expression . ;

    ;               shift and go to state 101


state 77

    (48) statement -> ; .

    ;               reduce using rule 48 (statement -> ; .)
    {               reduce using rule 48 (statement -> ; .)
    ID              reduce using rule 48 (statement -> ; .)
    NUMBER          reduce using rule 48 (statement -> ; .)
    CHR             reduce using rule 48 (statement -> ; .)
    STR             reduce using rule 48 (statement -> ; .)
    IF              reduce using rule 48 (statement -> ; .)
    WHILE           reduce using rule 48 (statement -> ; .)
    DO              reduce using rule 48 (statement -> ; .)
    FOR             reduce using rule 48 (statement -> ; .)
    RETURN          reduce using rule 48 (statement -> ; .)
    VOID            reduce using rule 48 (statement -> ; .)
    CHAR            reduce using rule 48 (statement -> ; .)
    SHORT           reduce using rule 48 (statement -> ; .)
    INT             reduce using rule 48 (statement -> ; .)
    LONG            reduce using rule 48 (statement -> ; .)
    FLOAT           reduce using rule 48 (statement -> ; .)
    DOUBLE          reduce using rule 48 (statement -> ; .)
    STRUCT          reduce using rule 48 (statement -> ; .)
    CLASS           reduce using rule 48 (statement -> ; .)
    }               reduce using rule 48 (statement -> ; .)


state 78

    (44) statement -> decl . ;

    ;               shift and go to state 102


state 79

    (45) statement -> conditional .

    ;               reduce using rule 45 (statement -> conditional .)
    {               reduce using rule 45 (statement -> conditional .)
    ID              reduce using rule 45 (statement -> conditional .)
    NUMBER          reduce using rule 45 (statement -> conditional .)
    CHR             reduce using rule 45 (statement -> conditional .)
    STR             reduce using rule 45 (statement -> conditional .)
    IF              reduce using rule 45 (statement -> conditional .)
    WHILE           reduce using rule 45 (statement -> conditional .)
    DO              reduce using rule 45 (statement -> conditional .)
    FOR             reduce using rule 45 (statement -> conditional .)
    RETURN          reduce using rule 45 (statement -> conditional .)
    VOID            reduce using rule 45 (statement -> conditional .)
    CHAR            reduce using rule 45 (statement -> conditional .)
    SHORT           reduce using rule 45 (statement -> conditional .)
    INT             reduce using rule 45 (statement -> conditional .)
    LONG            reduce using rule 45 (statement -> conditional .)
    FLOAT           reduce using rule 45 (statement -> conditional .)
    DOUBLE          reduce using rule 45 (statement -> conditional .)
    STRUCT          reduce using rule 45 (statement -> conditional .)
    CLASS           reduce using rule 45 (statement -> conditional .)
    }               reduce using rule 45 (statement -> conditional .)


state 80

    (46) statement -> iteration .

    ;               reduce using rule 46 (statement -> iteration .)
    {               reduce using rule 46 (statement -> iteration .)
    ID              reduce using rule 46 (statement -> iteration .)
    NUMBER          reduce using rule 46 (statement -> iteration .)
    CHR             reduce using rule 46 (statement -> iteration .)
    STR             reduce using rule 46 (statement -> iteration .)
    IF              reduce using rule 46 (statement -> iteration .)
    WHILE           reduce using rule 46 (statement -> iteration .)
    DO              reduce using rule 46 (statement -> iteration .)
    FOR             reduce using rule 46 (statement -> iteration .)
    RETURN          reduce using rule 46 (statement -> iteration .)
    VOID            reduce using rule 46 (statement -> iteration .)
    CHAR            reduce using rule 46 (statement -> iteration .)
    SHORT           reduce using rule 46 (statement -> iteration .)
    INT             reduce using rule 46 (statement -> iteration .)
    LONG            reduce using rule 46 (statement -> iteration .)
    FLOAT           reduce using rule 46 (statement -> iteration .)
    DOUBLE          reduce using rule 46 (statement -> iteration .)
    STRUCT          reduce using rule 46 (statement -> iteration .)
    CLASS           reduce using rule 46 (statement -> iteration .)
    }               reduce using rule 46 (statement -> iteration .)


state 81

    (47) statement -> jump . ;

    ;               shift and go to state 103


state 82

    (49) conditional -> IF . ( expression ) { stats_or_null }
    (50) conditional -> IF . ( expression ) { stats_or_null } ELSE conditional
    (51) conditional -> IF . ( expression ) { stats_or_null } ELSE { stats_or_null }

    (               shift and go to state 104


state 83

    (55) iteration -> WHILE . ( expression ) { stats_or_null }

    (               shift and go to state 105


state 84

    (56) iteration -> DO . { stats_or_null } WHILE ( expression ) ;

    {               shift and go to state 106


state 85

    (57) iteration -> FOR . ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null }

    (               shift and go to state 107


state 86

    (69) jump -> RETURN . expression
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (62) assignment_expr -> . ID assignmenteq_op expression

    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42

    expression                     shift and go to state 108
    assignment_expr                shift and go to state 43

state 87

    (38) params -> param , params .

    )               reduce using rule 38 (params -> param , params .)


state 88

    (62) assignment_expr -> ID assignmenteq_op expression .

    ]               reduce using rule 62 (assignment_expr -> ID assignmenteq_op expression .)
    ,               reduce using rule 62 (assignment_expr -> ID assignmenteq_op expression .)
    ;               reduce using rule 62 (assignment_expr -> ID assignmenteq_op expression .)
    }               reduce using rule 62 (assignment_expr -> ID assignmenteq_op expression .)
    )               reduce using rule 62 (assignment_expr -> ID assignmenteq_op expression .)


state 89

    (16) declarator_2 -> ID ( ) .

    =               reduce using rule 16 (declarator_2 -> ID ( ) .)
    ,               reduce using rule 16 (declarator_2 -> ID ( ) .)
    ;               reduce using rule 16 (declarator_2 -> ID ( ) .)
    )               reduce using rule 16 (declarator_2 -> ID ( ) .)


state 90

    (20) initializer -> { expressions } .

    ,               reduce using rule 20 (initializer -> { expressions } .)
    ;               reduce using rule 20 (initializer -> { expressions } .)


state 91

    (21) expressions -> expression , . expressions
    (21) expressions -> . expression , expressions
    (22) expressions -> . expression
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (62) assignment_expr -> . ID assignmenteq_op expression

    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42

    expression                     shift and go to state 66
    expressions                    shift and go to state 109
    assignment_expr                shift and go to state 43

state 92

    (28) new_type_dec -> new_type ID { new_type_params } ; .

    ;               reduce using rule 28 (new_type_dec -> new_type ID { new_type_params } ; .)


state 93

    (33) new_type_param -> type declarators ; .

    VOID            reduce using rule 33 (new_type_param -> type declarators ; .)
    CHAR            reduce using rule 33 (new_type_param -> type declarators ; .)
    SHORT           reduce using rule 33 (new_type_param -> type declarators ; .)
    INT             reduce using rule 33 (new_type_param -> type declarators ; .)
    LONG            reduce using rule 33 (new_type_param -> type declarators ; .)
    FLOAT           reduce using rule 33 (new_type_param -> type declarators ; .)
    DOUBLE          reduce using rule 33 (new_type_param -> type declarators ; .)
    }               reduce using rule 33 (new_type_param -> type declarators ; .)


state 94

    (34) func_def -> type ID ( params ) { statements . }

    }               shift and go to state 110


state 95

    (36) func_def -> type ID ( params ) { } .

    INCLUDE         reduce using rule 36 (func_def -> type ID ( params ) { } .)
    VOID            reduce using rule 36 (func_def -> type ID ( params ) { } .)
    CHAR            reduce using rule 36 (func_def -> type ID ( params ) { } .)
    SHORT           reduce using rule 36 (func_def -> type ID ( params ) { } .)
    INT             reduce using rule 36 (func_def -> type ID ( params ) { } .)
    LONG            reduce using rule 36 (func_def -> type ID ( params ) { } .)
    FLOAT           reduce using rule 36 (func_def -> type ID ( params ) { } .)
    DOUBLE          reduce using rule 36 (func_def -> type ID ( params ) { } .)
    STRUCT          reduce using rule 36 (func_def -> type ID ( params ) { } .)
    CLASS           reduce using rule 36 (func_def -> type ID ( params ) { } .)
    $end            reduce using rule 36 (func_def -> type ID ( params ) { } .)


state 96

    (52) statement -> { stats_or_null . }

    }               shift and go to state 111


state 97

    (53) stats_or_null -> statements .

    }               reduce using rule 53 (stats_or_null -> statements .)


state 98

    (54) stats_or_null -> empty .

    }               reduce using rule 54 (stats_or_null -> empty .)


state 99

    (35) func_def -> type ID ( ) { statements } .

    INCLUDE         reduce using rule 35 (func_def -> type ID ( ) { statements } .)
    VOID            reduce using rule 35 (func_def -> type ID ( ) { statements } .)
    CHAR            reduce using rule 35 (func_def -> type ID ( ) { statements } .)
    SHORT           reduce using rule 35 (func_def -> type ID ( ) { statements } .)
    INT             reduce using rule 35 (func_def -> type ID ( ) { statements } .)
    LONG            reduce using rule 35 (func_def -> type ID ( ) { statements } .)
    FLOAT           reduce using rule 35 (func_def -> type ID ( ) { statements } .)
    DOUBLE          reduce using rule 35 (func_def -> type ID ( ) { statements } .)
    STRUCT          reduce using rule 35 (func_def -> type ID ( ) { statements } .)
    CLASS           reduce using rule 35 (func_def -> type ID ( ) { statements } .)
    $end            reduce using rule 35 (func_def -> type ID ( ) { statements } .)


state 100

    (41) statements -> statement statements .

    }               reduce using rule 41 (statements -> statement statements .)


state 101

    (43) statement -> expression ; .

    ;               reduce using rule 43 (statement -> expression ; .)
    {               reduce using rule 43 (statement -> expression ; .)
    ID              reduce using rule 43 (statement -> expression ; .)
    NUMBER          reduce using rule 43 (statement -> expression ; .)
    CHR             reduce using rule 43 (statement -> expression ; .)
    STR             reduce using rule 43 (statement -> expression ; .)
    IF              reduce using rule 43 (statement -> expression ; .)
    WHILE           reduce using rule 43 (statement -> expression ; .)
    DO              reduce using rule 43 (statement -> expression ; .)
    FOR             reduce using rule 43 (statement -> expression ; .)
    RETURN          reduce using rule 43 (statement -> expression ; .)
    VOID            reduce using rule 43 (statement -> expression ; .)
    CHAR            reduce using rule 43 (statement -> expression ; .)
    SHORT           reduce using rule 43 (statement -> expression ; .)
    INT             reduce using rule 43 (statement -> expression ; .)
    LONG            reduce using rule 43 (statement -> expression ; .)
    FLOAT           reduce using rule 43 (statement -> expression ; .)
    DOUBLE          reduce using rule 43 (statement -> expression ; .)
    STRUCT          reduce using rule 43 (statement -> expression ; .)
    CLASS           reduce using rule 43 (statement -> expression ; .)
    }               reduce using rule 43 (statement -> expression ; .)


state 102

    (44) statement -> decl ; .

    ;               reduce using rule 44 (statement -> decl ; .)
    {               reduce using rule 44 (statement -> decl ; .)
    ID              reduce using rule 44 (statement -> decl ; .)
    NUMBER          reduce using rule 44 (statement -> decl ; .)
    CHR             reduce using rule 44 (statement -> decl ; .)
    STR             reduce using rule 44 (statement -> decl ; .)
    IF              reduce using rule 44 (statement -> decl ; .)
    WHILE           reduce using rule 44 (statement -> decl ; .)
    DO              reduce using rule 44 (statement -> decl ; .)
    FOR             reduce using rule 44 (statement -> decl ; .)
    RETURN          reduce using rule 44 (statement -> decl ; .)
    VOID            reduce using rule 44 (statement -> decl ; .)
    CHAR            reduce using rule 44 (statement -> decl ; .)
    SHORT           reduce using rule 44 (statement -> decl ; .)
    INT             reduce using rule 44 (statement -> decl ; .)
    LONG            reduce using rule 44 (statement -> decl ; .)
    FLOAT           reduce using rule 44 (statement -> decl ; .)
    DOUBLE          reduce using rule 44 (statement -> decl ; .)
    STRUCT          reduce using rule 44 (statement -> decl ; .)
    CLASS           reduce using rule 44 (statement -> decl ; .)
    }               reduce using rule 44 (statement -> decl ; .)


state 103

    (47) statement -> jump ; .

    ;               reduce using rule 47 (statement -> jump ; .)
    {               reduce using rule 47 (statement -> jump ; .)
    ID              reduce using rule 47 (statement -> jump ; .)
    NUMBER          reduce using rule 47 (statement -> jump ; .)
    CHR             reduce using rule 47 (statement -> jump ; .)
    STR             reduce using rule 47 (statement -> jump ; .)
    IF              reduce using rule 47 (statement -> jump ; .)
    WHILE           reduce using rule 47 (statement -> jump ; .)
    DO              reduce using rule 47 (statement -> jump ; .)
    FOR             reduce using rule 47 (statement -> jump ; .)
    RETURN          reduce using rule 47 (statement -> jump ; .)
    VOID            reduce using rule 47 (statement -> jump ; .)
    CHAR            reduce using rule 47 (statement -> jump ; .)
    SHORT           reduce using rule 47 (statement -> jump ; .)
    INT             reduce using rule 47 (statement -> jump ; .)
    LONG            reduce using rule 47 (statement -> jump ; .)
    FLOAT           reduce using rule 47 (statement -> jump ; .)
    DOUBLE          reduce using rule 47 (statement -> jump ; .)
    STRUCT          reduce using rule 47 (statement -> jump ; .)
    CLASS           reduce using rule 47 (statement -> jump ; .)
    }               reduce using rule 47 (statement -> jump ; .)


state 104

    (49) conditional -> IF ( . expression ) { stats_or_null }
    (50) conditional -> IF ( . expression ) { stats_or_null } ELSE conditional
    (51) conditional -> IF ( . expression ) { stats_or_null } ELSE { stats_or_null }
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (62) assignment_expr -> . ID assignmenteq_op expression

    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42

    expression                     shift and go to state 112
    assignment_expr                shift and go to state 43

state 105

    (55) iteration -> WHILE ( . expression ) { stats_or_null }
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (62) assignment_expr -> . ID assignmenteq_op expression

    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42

    expression                     shift and go to state 113
    assignment_expr                shift and go to state 43

state 106

    (56) iteration -> DO { . stats_or_null } WHILE ( expression ) ;
    (53) stats_or_null -> . statements
    (54) stats_or_null -> . empty
    (41) statements -> . statement statements
    (42) statements -> . statement
    (77) empty -> .
    (43) statement -> . expression ;
    (44) statement -> . decl ;
    (45) statement -> . conditional
    (46) statement -> . iteration
    (47) statement -> . jump ;
    (48) statement -> . ;
    (52) statement -> . { stats_or_null }
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (8) decl -> . usual_dec
    (9) decl -> . new_type_dec
    (49) conditional -> . IF ( expression ) { stats_or_null }
    (50) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (51) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (55) iteration -> . WHILE ( expression ) { stats_or_null }
    (56) iteration -> . DO { stats_or_null } WHILE ( expression ) ;
    (57) iteration -> . FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null }
    (69) jump -> . RETURN expression
    (62) assignment_expr -> . ID assignmenteq_op expression
    (10) usual_dec -> . type declarators
    (28) new_type_dec -> . new_type ID { new_type_params } ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (29) new_type -> . STRUCT
    (30) new_type -> . CLASS

    }               reduce using rule 77 (empty -> .)
    ;               shift and go to state 77
    {               shift and go to state 72
    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42
    IF              shift and go to state 82
    WHILE           shift and go to state 83
    DO              shift and go to state 84
    FOR             shift and go to state 85
    RETURN          shift and go to state 86
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17
    STRUCT          shift and go to state 18
    CLASS           shift and go to state 19

    stats_or_null                  shift and go to state 114
    expression                     shift and go to state 76
    statements                     shift and go to state 97
    empty                          shift and go to state 98
    statement                      shift and go to state 75
    decl                           shift and go to state 78
    conditional                    shift and go to state 79
    iteration                      shift and go to state 80
    jump                           shift and go to state 81
    assignment_expr                shift and go to state 43
    usual_dec                      shift and go to state 7
    new_type_dec                   shift and go to state 8
    type                           shift and go to state 71
    new_type                       shift and go to state 10

state 107

    (57) iteration -> FOR ( . expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null }
    (60) expr_or_null_or_init -> . expr_or_null
    (61) expr_or_null_or_init -> . usual_dec
    (58) expr_or_null -> . expression
    (59) expr_or_null -> . empty
    (10) usual_dec -> . type declarators
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (77) empty -> .
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (62) assignment_expr -> . ID assignmenteq_op expression

    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42
    ;               reduce using rule 77 (empty -> .)
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17

    expr_or_null_or_init           shift and go to state 115
    expr_or_null                   shift and go to state 116
    usual_dec                      shift and go to state 117
    expression                     shift and go to state 118
    empty                          shift and go to state 119
    type                           shift and go to state 71
    assignment_expr                shift and go to state 43

state 108

    (69) jump -> RETURN expression .

    ;               reduce using rule 69 (jump -> RETURN expression .)


state 109

    (21) expressions -> expression , expressions .

    }               reduce using rule 21 (expressions -> expression , expressions .)


state 110

    (34) func_def -> type ID ( params ) { statements } .

    INCLUDE         reduce using rule 34 (func_def -> type ID ( params ) { statements } .)
    VOID            reduce using rule 34 (func_def -> type ID ( params ) { statements } .)
    CHAR            reduce using rule 34 (func_def -> type ID ( params ) { statements } .)
    SHORT           reduce using rule 34 (func_def -> type ID ( params ) { statements } .)
    INT             reduce using rule 34 (func_def -> type ID ( params ) { statements } .)
    LONG            reduce using rule 34 (func_def -> type ID ( params ) { statements } .)
    FLOAT           reduce using rule 34 (func_def -> type ID ( params ) { statements } .)
    DOUBLE          reduce using rule 34 (func_def -> type ID ( params ) { statements } .)
    STRUCT          reduce using rule 34 (func_def -> type ID ( params ) { statements } .)
    CLASS           reduce using rule 34 (func_def -> type ID ( params ) { statements } .)
    $end            reduce using rule 34 (func_def -> type ID ( params ) { statements } .)


state 111

    (52) statement -> { stats_or_null } .

    ;               reduce using rule 52 (statement -> { stats_or_null } .)
    {               reduce using rule 52 (statement -> { stats_or_null } .)
    ID              reduce using rule 52 (statement -> { stats_or_null } .)
    NUMBER          reduce using rule 52 (statement -> { stats_or_null } .)
    CHR             reduce using rule 52 (statement -> { stats_or_null } .)
    STR             reduce using rule 52 (statement -> { stats_or_null } .)
    IF              reduce using rule 52 (statement -> { stats_or_null } .)
    WHILE           reduce using rule 52 (statement -> { stats_or_null } .)
    DO              reduce using rule 52 (statement -> { stats_or_null } .)
    FOR             reduce using rule 52 (statement -> { stats_or_null } .)
    RETURN          reduce using rule 52 (statement -> { stats_or_null } .)
    VOID            reduce using rule 52 (statement -> { stats_or_null } .)
    CHAR            reduce using rule 52 (statement -> { stats_or_null } .)
    SHORT           reduce using rule 52 (statement -> { stats_or_null } .)
    INT             reduce using rule 52 (statement -> { stats_or_null } .)
    LONG            reduce using rule 52 (statement -> { stats_or_null } .)
    FLOAT           reduce using rule 52 (statement -> { stats_or_null } .)
    DOUBLE          reduce using rule 52 (statement -> { stats_or_null } .)
    STRUCT          reduce using rule 52 (statement -> { stats_or_null } .)
    CLASS           reduce using rule 52 (statement -> { stats_or_null } .)
    }               reduce using rule 52 (statement -> { stats_or_null } .)


state 112

    (49) conditional -> IF ( expression . ) { stats_or_null }
    (50) conditional -> IF ( expression . ) { stats_or_null } ELSE conditional
    (51) conditional -> IF ( expression . ) { stats_or_null } ELSE { stats_or_null }

    )               shift and go to state 120


state 113

    (55) iteration -> WHILE ( expression . ) { stats_or_null }

    )               shift and go to state 121


state 114

    (56) iteration -> DO { stats_or_null . } WHILE ( expression ) ;

    }               shift and go to state 122


state 115

    (57) iteration -> FOR ( expr_or_null_or_init . ; expr_or_null ; expr_or_null ) { stats_or_null }

    ;               shift and go to state 123


state 116

    (60) expr_or_null_or_init -> expr_or_null .

    ;               reduce using rule 60 (expr_or_null_or_init -> expr_or_null .)


state 117

    (61) expr_or_null_or_init -> usual_dec .

    ;               reduce using rule 61 (expr_or_null_or_init -> usual_dec .)


state 118

    (58) expr_or_null -> expression .

    ;               reduce using rule 58 (expr_or_null -> expression .)
    )               reduce using rule 58 (expr_or_null -> expression .)


state 119

    (59) expr_or_null -> empty .

    ;               reduce using rule 59 (expr_or_null -> empty .)
    )               reduce using rule 59 (expr_or_null -> empty .)


state 120

    (49) conditional -> IF ( expression ) . { stats_or_null }
    (50) conditional -> IF ( expression ) . { stats_or_null } ELSE conditional
    (51) conditional -> IF ( expression ) . { stats_or_null } ELSE { stats_or_null }

    {               shift and go to state 124


state 121

    (55) iteration -> WHILE ( expression ) . { stats_or_null }

    {               shift and go to state 125


state 122

    (56) iteration -> DO { stats_or_null } . WHILE ( expression ) ;

    WHILE           shift and go to state 126


state 123

    (57) iteration -> FOR ( expr_or_null_or_init ; . expr_or_null ; expr_or_null ) { stats_or_null }
    (58) expr_or_null -> . expression
    (59) expr_or_null -> . empty
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (77) empty -> .
    (62) assignment_expr -> . ID assignmenteq_op expression

    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42
    ;               reduce using rule 77 (empty -> .)

    expr_or_null                   shift and go to state 127
    expression                     shift and go to state 118
    empty                          shift and go to state 119
    assignment_expr                shift and go to state 43

state 124

    (49) conditional -> IF ( expression ) { . stats_or_null }
    (50) conditional -> IF ( expression ) { . stats_or_null } ELSE conditional
    (51) conditional -> IF ( expression ) { . stats_or_null } ELSE { stats_or_null }
    (53) stats_or_null -> . statements
    (54) stats_or_null -> . empty
    (41) statements -> . statement statements
    (42) statements -> . statement
    (77) empty -> .
    (43) statement -> . expression ;
    (44) statement -> . decl ;
    (45) statement -> . conditional
    (46) statement -> . iteration
    (47) statement -> . jump ;
    (48) statement -> . ;
    (52) statement -> . { stats_or_null }
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (8) decl -> . usual_dec
    (9) decl -> . new_type_dec
    (49) conditional -> . IF ( expression ) { stats_or_null }
    (50) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (51) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (55) iteration -> . WHILE ( expression ) { stats_or_null }
    (56) iteration -> . DO { stats_or_null } WHILE ( expression ) ;
    (57) iteration -> . FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null }
    (69) jump -> . RETURN expression
    (62) assignment_expr -> . ID assignmenteq_op expression
    (10) usual_dec -> . type declarators
    (28) new_type_dec -> . new_type ID { new_type_params } ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (29) new_type -> . STRUCT
    (30) new_type -> . CLASS

    }               reduce using rule 77 (empty -> .)
    ;               shift and go to state 77
    {               shift and go to state 72
    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42
    IF              shift and go to state 82
    WHILE           shift and go to state 83
    DO              shift and go to state 84
    FOR             shift and go to state 85
    RETURN          shift and go to state 86
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17
    STRUCT          shift and go to state 18
    CLASS           shift and go to state 19

    expression                     shift and go to state 76
    stats_or_null                  shift and go to state 128
    conditional                    shift and go to state 79
    statements                     shift and go to state 97
    empty                          shift and go to state 98
    statement                      shift and go to state 75
    decl                           shift and go to state 78
    iteration                      shift and go to state 80
    jump                           shift and go to state 81
    assignment_expr                shift and go to state 43
    usual_dec                      shift and go to state 7
    new_type_dec                   shift and go to state 8
    type                           shift and go to state 71
    new_type                       shift and go to state 10

state 125

    (55) iteration -> WHILE ( expression ) { . stats_or_null }
    (53) stats_or_null -> . statements
    (54) stats_or_null -> . empty
    (41) statements -> . statement statements
    (42) statements -> . statement
    (77) empty -> .
    (43) statement -> . expression ;
    (44) statement -> . decl ;
    (45) statement -> . conditional
    (46) statement -> . iteration
    (47) statement -> . jump ;
    (48) statement -> . ;
    (52) statement -> . { stats_or_null }
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (8) decl -> . usual_dec
    (9) decl -> . new_type_dec
    (49) conditional -> . IF ( expression ) { stats_or_null }
    (50) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (51) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (55) iteration -> . WHILE ( expression ) { stats_or_null }
    (56) iteration -> . DO { stats_or_null } WHILE ( expression ) ;
    (57) iteration -> . FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null }
    (69) jump -> . RETURN expression
    (62) assignment_expr -> . ID assignmenteq_op expression
    (10) usual_dec -> . type declarators
    (28) new_type_dec -> . new_type ID { new_type_params } ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (29) new_type -> . STRUCT
    (30) new_type -> . CLASS

    }               reduce using rule 77 (empty -> .)
    ;               shift and go to state 77
    {               shift and go to state 72
    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42
    IF              shift and go to state 82
    WHILE           shift and go to state 83
    DO              shift and go to state 84
    FOR             shift and go to state 85
    RETURN          shift and go to state 86
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17
    STRUCT          shift and go to state 18
    CLASS           shift and go to state 19

    expression                     shift and go to state 76
    stats_or_null                  shift and go to state 129
    statements                     shift and go to state 97
    empty                          shift and go to state 98
    statement                      shift and go to state 75
    decl                           shift and go to state 78
    conditional                    shift and go to state 79
    iteration                      shift and go to state 80
    jump                           shift and go to state 81
    assignment_expr                shift and go to state 43
    usual_dec                      shift and go to state 7
    new_type_dec                   shift and go to state 8
    type                           shift and go to state 71
    new_type                       shift and go to state 10

state 126

    (56) iteration -> DO { stats_or_null } WHILE . ( expression ) ;

    (               shift and go to state 130


state 127

    (57) iteration -> FOR ( expr_or_null_or_init ; expr_or_null . ; expr_or_null ) { stats_or_null }

    ;               shift and go to state 131


state 128

    (49) conditional -> IF ( expression ) { stats_or_null . }
    (50) conditional -> IF ( expression ) { stats_or_null . } ELSE conditional
    (51) conditional -> IF ( expression ) { stats_or_null . } ELSE { stats_or_null }

    }               shift and go to state 132


state 129

    (55) iteration -> WHILE ( expression ) { stats_or_null . }

    }               shift and go to state 133


state 130

    (56) iteration -> DO { stats_or_null } WHILE ( . expression ) ;
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (62) assignment_expr -> . ID assignmenteq_op expression

    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42

    expression                     shift and go to state 134
    assignment_expr                shift and go to state 43

state 131

    (57) iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; . expr_or_null ) { stats_or_null }
    (58) expr_or_null -> . expression
    (59) expr_or_null -> . empty
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (77) empty -> .
    (62) assignment_expr -> . ID assignmenteq_op expression

    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42
    )               reduce using rule 77 (empty -> .)

    expr_or_null                   shift and go to state 135
    expression                     shift and go to state 118
    empty                          shift and go to state 119
    assignment_expr                shift and go to state 43

state 132

    (49) conditional -> IF ( expression ) { stats_or_null } .
    (50) conditional -> IF ( expression ) { stats_or_null } . ELSE conditional
    (51) conditional -> IF ( expression ) { stats_or_null } . ELSE { stats_or_null }

    ;               reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    {               reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    ID              reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    NUMBER          reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    CHR             reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    STR             reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    IF              reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    WHILE           reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    DO              reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    FOR             reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    RETURN          reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    VOID            reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    CHAR            reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    SHORT           reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    INT             reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    LONG            reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    FLOAT           reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    DOUBLE          reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    STRUCT          reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    CLASS           reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    }               reduce using rule 49 (conditional -> IF ( expression ) { stats_or_null } .)
    ELSE            shift and go to state 136


state 133

    (55) iteration -> WHILE ( expression ) { stats_or_null } .

    ;               reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    {               reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    ID              reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    NUMBER          reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    CHR             reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    STR             reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    IF              reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    WHILE           reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    DO              reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    FOR             reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    RETURN          reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    VOID            reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    CHAR            reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    SHORT           reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    INT             reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    LONG            reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    FLOAT           reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    DOUBLE          reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    STRUCT          reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    CLASS           reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)
    }               reduce using rule 55 (iteration -> WHILE ( expression ) { stats_or_null } .)


state 134

    (56) iteration -> DO { stats_or_null } WHILE ( expression . ) ;

    )               shift and go to state 137


state 135

    (57) iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null . ) { stats_or_null }

    )               shift and go to state 138


state 136

    (50) conditional -> IF ( expression ) { stats_or_null } ELSE . conditional
    (51) conditional -> IF ( expression ) { stats_or_null } ELSE . { stats_or_null }
    (49) conditional -> . IF ( expression ) { stats_or_null }
    (50) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (51) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }

    {               shift and go to state 139
    IF              shift and go to state 82

    conditional                    shift and go to state 140

state 137

    (56) iteration -> DO { stats_or_null } WHILE ( expression ) . ;

    ;               shift and go to state 141


state 138

    (57) iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) . { stats_or_null }

    {               shift and go to state 142


state 139

    (51) conditional -> IF ( expression ) { stats_or_null } ELSE { . stats_or_null }
    (53) stats_or_null -> . statements
    (54) stats_or_null -> . empty
    (41) statements -> . statement statements
    (42) statements -> . statement
    (77) empty -> .
    (43) statement -> . expression ;
    (44) statement -> . decl ;
    (45) statement -> . conditional
    (46) statement -> . iteration
    (47) statement -> . jump ;
    (48) statement -> . ;
    (52) statement -> . { stats_or_null }
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (8) decl -> . usual_dec
    (9) decl -> . new_type_dec
    (49) conditional -> . IF ( expression ) { stats_or_null }
    (50) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (51) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (55) iteration -> . WHILE ( expression ) { stats_or_null }
    (56) iteration -> . DO { stats_or_null } WHILE ( expression ) ;
    (57) iteration -> . FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null }
    (69) jump -> . RETURN expression
    (62) assignment_expr -> . ID assignmenteq_op expression
    (10) usual_dec -> . type declarators
    (28) new_type_dec -> . new_type ID { new_type_params } ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (29) new_type -> . STRUCT
    (30) new_type -> . CLASS

    }               reduce using rule 77 (empty -> .)
    ;               shift and go to state 77
    {               shift and go to state 72
    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42
    IF              shift and go to state 82
    WHILE           shift and go to state 83
    DO              shift and go to state 84
    FOR             shift and go to state 85
    RETURN          shift and go to state 86
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17
    STRUCT          shift and go to state 18
    CLASS           shift and go to state 19

    expression                     shift and go to state 76
    stats_or_null                  shift and go to state 143
    statements                     shift and go to state 97
    empty                          shift and go to state 98
    statement                      shift and go to state 75
    decl                           shift and go to state 78
    conditional                    shift and go to state 79
    iteration                      shift and go to state 80
    jump                           shift and go to state 81
    assignment_expr                shift and go to state 43
    usual_dec                      shift and go to state 7
    new_type_dec                   shift and go to state 8
    type                           shift and go to state 71
    new_type                       shift and go to state 10

state 140

    (50) conditional -> IF ( expression ) { stats_or_null } ELSE conditional .

    ;               reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    {               reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    ID              reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    NUMBER          reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    CHR             reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    STR             reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    IF              reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    WHILE           reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    DO              reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    FOR             reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    RETURN          reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    VOID            reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    CHAR            reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    SHORT           reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    INT             reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    LONG            reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    FLOAT           reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    DOUBLE          reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    STRUCT          reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    CLASS           reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    }               reduce using rule 50 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)


state 141

    (56) iteration -> DO { stats_or_null } WHILE ( expression ) ; .

    ;               reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    {               reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    ID              reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    NUMBER          reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    CHR             reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    STR             reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    IF              reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    WHILE           reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    DO              reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    FOR             reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    RETURN          reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    VOID            reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    CHAR            reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    SHORT           reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    INT             reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    LONG            reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    FLOAT           reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    DOUBLE          reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    STRUCT          reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    CLASS           reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)
    }               reduce using rule 56 (iteration -> DO { stats_or_null } WHILE ( expression ) ; .)


state 142

    (57) iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { . stats_or_null }
    (53) stats_or_null -> . statements
    (54) stats_or_null -> . empty
    (41) statements -> . statement statements
    (42) statements -> . statement
    (77) empty -> .
    (43) statement -> . expression ;
    (44) statement -> . decl ;
    (45) statement -> . conditional
    (46) statement -> . iteration
    (47) statement -> . jump ;
    (48) statement -> . ;
    (52) statement -> . { stats_or_null }
    (23) expression -> . ID
    (24) expression -> . NUMBER
    (25) expression -> . CHR
    (26) expression -> . STR
    (27) expression -> . assignment_expr
    (8) decl -> . usual_dec
    (9) decl -> . new_type_dec
    (49) conditional -> . IF ( expression ) { stats_or_null }
    (50) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (51) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (55) iteration -> . WHILE ( expression ) { stats_or_null }
    (56) iteration -> . DO { stats_or_null } WHILE ( expression ) ;
    (57) iteration -> . FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null }
    (69) jump -> . RETURN expression
    (62) assignment_expr -> . ID assignmenteq_op expression
    (10) usual_dec -> . type declarators
    (28) new_type_dec -> . new_type ID { new_type_params } ;
    (70) type -> . VOID
    (71) type -> . CHAR
    (72) type -> . SHORT
    (73) type -> . INT
    (74) type -> . LONG
    (75) type -> . FLOAT
    (76) type -> . DOUBLE
    (29) new_type -> . STRUCT
    (30) new_type -> . CLASS

    }               reduce using rule 77 (empty -> .)
    ;               shift and go to state 77
    {               shift and go to state 72
    ID              shift and go to state 37
    NUMBER          shift and go to state 40
    CHR             shift and go to state 41
    STR             shift and go to state 42
    IF              shift and go to state 82
    WHILE           shift and go to state 83
    DO              shift and go to state 84
    FOR             shift and go to state 85
    RETURN          shift and go to state 86
    VOID            shift and go to state 11
    CHAR            shift and go to state 12
    SHORT           shift and go to state 13
    INT             shift and go to state 14
    LONG            shift and go to state 15
    FLOAT           shift and go to state 16
    DOUBLE          shift and go to state 17
    STRUCT          shift and go to state 18
    CLASS           shift and go to state 19

    stats_or_null                  shift and go to state 144
    statements                     shift and go to state 97
    empty                          shift and go to state 98
    statement                      shift and go to state 75
    expression                     shift and go to state 76
    decl                           shift and go to state 78
    conditional                    shift and go to state 79
    iteration                      shift and go to state 80
    jump                           shift and go to state 81
    assignment_expr                shift and go to state 43
    usual_dec                      shift and go to state 7
    new_type_dec                   shift and go to state 8
    type                           shift and go to state 71
    new_type                       shift and go to state 10

state 143

    (51) conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null . }

    }               shift and go to state 145


state 144

    (57) iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null . }

    }               shift and go to state 146


state 145

    (51) conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .

    ;               reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    {               reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    ID              reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    NUMBER          reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    CHR             reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    STR             reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    IF              reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    WHILE           reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    DO              reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    FOR             reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    RETURN          reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    VOID            reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    CHAR            reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    SHORT           reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    INT             reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    LONG            reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    FLOAT           reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    DOUBLE          reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    STRUCT          reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    CLASS           reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    }               reduce using rule 51 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)


state 146

    (57) iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .

    ;               reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    {               reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    ID              reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    NUMBER          reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    CHR             reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    STR             reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    IF              reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    WHILE           reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    DO              reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    FOR             reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    RETURN          reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    VOID            reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    CHAR            reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    SHORT           reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    INT             reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    LONG            reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    FLOAT           reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    DOUBLE          reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    STRUCT          reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    CLASS           reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)
    }               reduce using rule 57 (iteration -> FOR ( expr_or_null_or_init ; expr_or_null ; expr_or_null ) { stats_or_null } .)

