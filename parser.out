Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    GEQ
    LEQ
    RETURN
    THEN
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> include program
Rule 2     program -> external_decl program
Rule 3     program -> include
Rule 4     program -> external_decl
Rule 5     include -> INCLUDE
Rule 6     external_decl -> decl ;
Rule 7     external_decl -> func_def
Rule 8     decl -> type declarators
Rule 9     decl -> new_type_dec
Rule 10    declarators -> declarator_1 , declarators
Rule 11    declarators -> declarator_1
Rule 12    declarator_1 -> declarator_2
Rule 13    declarator_1 -> declarator_2 = initializer
Rule 14    declarator_2 -> ID
Rule 15    declarator_2 -> ID ( )
Rule 16    declarator_2 -> ID [ ]
Rule 17    declarator_2 -> ID [ expression ]
Rule 18    initializer -> expression
Rule 19    initializer -> { expressions }
Rule 20    expressions -> expression , expressions
Rule 21    expressions -> expression
Rule 22    expression -> ID
Rule 23    expression -> NUMBER
Rule 24    expression -> CHR
Rule 25    expression -> STR
Rule 26    new_type_dec -> new_type ID { new_type_params } ;
Rule 27    new_type -> STRUCT
Rule 28    new_type -> CLASS
Rule 29    new_type_params -> new_type_param new_type_params
Rule 30    new_type_params -> new_type_param
Rule 31    new_type_param -> type declarators ;
Rule 32    func_def -> type ID ( params ) { statements }
Rule 33    func_def -> type ID ( ) { statements }
Rule 34    func_def -> type ID ( params ) { }
Rule 35    func_def -> type ID ( ) { }
Rule 36    params -> param , params
Rule 37    params -> param
Rule 38    param -> type declarator_2
Rule 39    statements -> statement statements
Rule 40    statements -> statement
Rule 41    statement -> expression ;
Rule 42    statement -> decl ;
Rule 43    statement -> assignment_expr ;
Rule 44    statement -> conditional
Rule 45    conditional -> IF ( expression ) { stats_or_null }
Rule 46    conditional -> IF ( expression ) { stats_or_null } ELSE conditional
Rule 47    conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null }
Rule 48    stats_or_null -> statements
Rule 49    stats_or_null -> empty
Rule 50    statement -> { stats_or_null }
Rule 51    assignment_expr -> ID assignmenteq_op expression
Rule 52    assignmenteq_op -> MULTEQ
Rule 53    assignmenteq_op -> ADDEQ
Rule 54    assignmenteq_op -> SUBEQ
Rule 55    assignmenteq_op -> MODEQ
Rule 56    assignmenteq_op -> DIVEQ
Rule 57    type -> VOID
Rule 58    type -> CHAR
Rule 59    type -> SHORT
Rule 60    type -> INT
Rule 61    type -> LONG
Rule 62    type -> FLOAT
Rule 63    type -> DOUBLE
Rule 64    empty -> <empty>

Terminals, with rules where they appear

(                    : 15 32 33 34 35 45 46 47
)                    : 15 32 33 34 35 45 46 47
,                    : 10 20 36
;                    : 6 26 31 41 42 43
=                    : 13
ADDEQ                : 53
BREAK                : 
CHAR                 : 58
CHR                  : 24
CLASS                : 28
DIVEQ                : 56
DOUBLE               : 63
ELSE                 : 46 47
FLOAT                : 62
GEQ                  : 
ID                   : 14 15 16 17 22 26 32 33 34 35 51
IF                   : 45 46 47
INCLUDE              : 5
INT                  : 60
LEQ                  : 
LONG                 : 61
MODEQ                : 55
MULTEQ               : 52
NUMBER               : 23
RETURN               : 
SHORT                : 59
STR                  : 25
STRUCT               : 27
SUBEQ                : 54
THEN                 : 
VOID                 : 57
WHILE                : 
[                    : 16 17
]                    : 16 17
error                : 
{                    : 19 26 32 33 34 35 45 46 47 47 50
}                    : 19 26 32 33 34 35 45 46 47 47 50

Nonterminals, with rules where they appear

assignment_expr      : 43
assignmenteq_op      : 51
conditional          : 44 46
decl                 : 6 42
declarator_1         : 10 11
declarator_2         : 12 13 38
declarators          : 8 10 31
empty                : 49
expression           : 17 18 20 21 41 45 46 47 51
expressions          : 19 20
external_decl        : 2 4
func_def             : 7
include              : 1 3
initializer          : 13
new_type             : 26
new_type_dec         : 9
new_type_param       : 29 30
new_type_params      : 26 29
param                : 36 37
params               : 32 34 36
program              : 1 2 0
statement            : 39 40
statements           : 32 33 39 48
stats_or_null        : 45 46 47 47 50
type                 : 8 31 32 33 34 35 38

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . include program
    (2) program -> . external_decl program
    (3) program -> . include
    (4) program -> . external_decl
    (5) include -> . INCLUDE
    (6) external_decl -> . decl ;
    (7) external_decl -> . func_def
    (8) decl -> . type declarators
    (9) decl -> . new_type_dec
    (32) func_def -> . type ID ( params ) { statements }
    (33) func_def -> . type ID ( ) { statements }
    (34) func_def -> . type ID ( params ) { }
    (35) func_def -> . type ID ( ) { }
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE
    (26) new_type_dec -> . new_type ID { new_type_params } ;
    (27) new_type -> . STRUCT
    (28) new_type -> . CLASS

    INCLUDE         shift and go to state 4
    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15
    STRUCT          shift and go to state 17
    CLASS           shift and go to state 18

    program                        shift and go to state 1
    include                        shift and go to state 2
    external_decl                  shift and go to state 3
    decl                           shift and go to state 5
    func_def                       shift and go to state 6
    type                           shift and go to state 7
    new_type_dec                   shift and go to state 8
    new_type                       shift and go to state 16

state 1

    (0) S' -> program .



state 2

    (1) program -> include . program
    (3) program -> include .
    (1) program -> . include program
    (2) program -> . external_decl program
    (3) program -> . include
    (4) program -> . external_decl
    (5) include -> . INCLUDE
    (6) external_decl -> . decl ;
    (7) external_decl -> . func_def
    (8) decl -> . type declarators
    (9) decl -> . new_type_dec
    (32) func_def -> . type ID ( params ) { statements }
    (33) func_def -> . type ID ( ) { statements }
    (34) func_def -> . type ID ( params ) { }
    (35) func_def -> . type ID ( ) { }
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE
    (26) new_type_dec -> . new_type ID { new_type_params } ;
    (27) new_type -> . STRUCT
    (28) new_type -> . CLASS

    $end            reduce using rule 3 (program -> include .)
    INCLUDE         shift and go to state 4
    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15
    STRUCT          shift and go to state 17
    CLASS           shift and go to state 18

    include                        shift and go to state 2
    program                        shift and go to state 19
    external_decl                  shift and go to state 3
    decl                           shift and go to state 5
    func_def                       shift and go to state 6
    type                           shift and go to state 7
    new_type_dec                   shift and go to state 8
    new_type                       shift and go to state 16

state 3

    (2) program -> external_decl . program
    (4) program -> external_decl .
    (1) program -> . include program
    (2) program -> . external_decl program
    (3) program -> . include
    (4) program -> . external_decl
    (5) include -> . INCLUDE
    (6) external_decl -> . decl ;
    (7) external_decl -> . func_def
    (8) decl -> . type declarators
    (9) decl -> . new_type_dec
    (32) func_def -> . type ID ( params ) { statements }
    (33) func_def -> . type ID ( ) { statements }
    (34) func_def -> . type ID ( params ) { }
    (35) func_def -> . type ID ( ) { }
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE
    (26) new_type_dec -> . new_type ID { new_type_params } ;
    (27) new_type -> . STRUCT
    (28) new_type -> . CLASS

    $end            reduce using rule 4 (program -> external_decl .)
    INCLUDE         shift and go to state 4
    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15
    STRUCT          shift and go to state 17
    CLASS           shift and go to state 18

    external_decl                  shift and go to state 3
    program                        shift and go to state 20
    include                        shift and go to state 2
    decl                           shift and go to state 5
    func_def                       shift and go to state 6
    type                           shift and go to state 7
    new_type_dec                   shift and go to state 8
    new_type                       shift and go to state 16

state 4

    (5) include -> INCLUDE .

    INCLUDE         reduce using rule 5 (include -> INCLUDE .)
    VOID            reduce using rule 5 (include -> INCLUDE .)
    CHAR            reduce using rule 5 (include -> INCLUDE .)
    SHORT           reduce using rule 5 (include -> INCLUDE .)
    INT             reduce using rule 5 (include -> INCLUDE .)
    LONG            reduce using rule 5 (include -> INCLUDE .)
    FLOAT           reduce using rule 5 (include -> INCLUDE .)
    DOUBLE          reduce using rule 5 (include -> INCLUDE .)
    STRUCT          reduce using rule 5 (include -> INCLUDE .)
    CLASS           reduce using rule 5 (include -> INCLUDE .)
    $end            reduce using rule 5 (include -> INCLUDE .)


state 5

    (6) external_decl -> decl . ;

    ;               shift and go to state 21


state 6

    (7) external_decl -> func_def .

    INCLUDE         reduce using rule 7 (external_decl -> func_def .)
    VOID            reduce using rule 7 (external_decl -> func_def .)
    CHAR            reduce using rule 7 (external_decl -> func_def .)
    SHORT           reduce using rule 7 (external_decl -> func_def .)
    INT             reduce using rule 7 (external_decl -> func_def .)
    LONG            reduce using rule 7 (external_decl -> func_def .)
    FLOAT           reduce using rule 7 (external_decl -> func_def .)
    DOUBLE          reduce using rule 7 (external_decl -> func_def .)
    STRUCT          reduce using rule 7 (external_decl -> func_def .)
    CLASS           reduce using rule 7 (external_decl -> func_def .)
    $end            reduce using rule 7 (external_decl -> func_def .)


state 7

    (8) decl -> type . declarators
    (32) func_def -> type . ID ( params ) { statements }
    (33) func_def -> type . ID ( ) { statements }
    (34) func_def -> type . ID ( params ) { }
    (35) func_def -> type . ID ( ) { }
    (10) declarators -> . declarator_1 , declarators
    (11) declarators -> . declarator_1
    (12) declarator_1 -> . declarator_2
    (13) declarator_1 -> . declarator_2 = initializer
    (14) declarator_2 -> . ID
    (15) declarator_2 -> . ID ( )
    (16) declarator_2 -> . ID [ ]
    (17) declarator_2 -> . ID [ expression ]

    ID              shift and go to state 23

    declarators                    shift and go to state 22
    declarator_1                   shift and go to state 24
    declarator_2                   shift and go to state 25

state 8

    (9) decl -> new_type_dec .

    ;               reduce using rule 9 (decl -> new_type_dec .)


state 9

    (57) type -> VOID .

    ID              reduce using rule 57 (type -> VOID .)


state 10

    (58) type -> CHAR .

    ID              reduce using rule 58 (type -> CHAR .)


state 11

    (59) type -> SHORT .

    ID              reduce using rule 59 (type -> SHORT .)


state 12

    (60) type -> INT .

    ID              reduce using rule 60 (type -> INT .)


state 13

    (61) type -> LONG .

    ID              reduce using rule 61 (type -> LONG .)


state 14

    (62) type -> FLOAT .

    ID              reduce using rule 62 (type -> FLOAT .)


state 15

    (63) type -> DOUBLE .

    ID              reduce using rule 63 (type -> DOUBLE .)


state 16

    (26) new_type_dec -> new_type . ID { new_type_params } ;

    ID              shift and go to state 26


state 17

    (27) new_type -> STRUCT .

    ID              reduce using rule 27 (new_type -> STRUCT .)


state 18

    (28) new_type -> CLASS .

    ID              reduce using rule 28 (new_type -> CLASS .)


state 19

    (1) program -> include program .

    $end            reduce using rule 1 (program -> include program .)


state 20

    (2) program -> external_decl program .

    $end            reduce using rule 2 (program -> external_decl program .)


state 21

    (6) external_decl -> decl ; .

    INCLUDE         reduce using rule 6 (external_decl -> decl ; .)
    VOID            reduce using rule 6 (external_decl -> decl ; .)
    CHAR            reduce using rule 6 (external_decl -> decl ; .)
    SHORT           reduce using rule 6 (external_decl -> decl ; .)
    INT             reduce using rule 6 (external_decl -> decl ; .)
    LONG            reduce using rule 6 (external_decl -> decl ; .)
    FLOAT           reduce using rule 6 (external_decl -> decl ; .)
    DOUBLE          reduce using rule 6 (external_decl -> decl ; .)
    STRUCT          reduce using rule 6 (external_decl -> decl ; .)
    CLASS           reduce using rule 6 (external_decl -> decl ; .)
    $end            reduce using rule 6 (external_decl -> decl ; .)


state 22

    (8) decl -> type declarators .

    ;               reduce using rule 8 (decl -> type declarators .)


state 23

    (32) func_def -> type ID . ( params ) { statements }
    (33) func_def -> type ID . ( ) { statements }
    (34) func_def -> type ID . ( params ) { }
    (35) func_def -> type ID . ( ) { }
    (14) declarator_2 -> ID .
    (15) declarator_2 -> ID . ( )
    (16) declarator_2 -> ID . [ ]
    (17) declarator_2 -> ID . [ expression ]

    (               shift and go to state 27
    =               reduce using rule 14 (declarator_2 -> ID .)
    ,               reduce using rule 14 (declarator_2 -> ID .)
    ;               reduce using rule 14 (declarator_2 -> ID .)
    [               shift and go to state 28


state 24

    (10) declarators -> declarator_1 . , declarators
    (11) declarators -> declarator_1 .

    ,               shift and go to state 29
    ;               reduce using rule 11 (declarators -> declarator_1 .)


state 25

    (12) declarator_1 -> declarator_2 .
    (13) declarator_1 -> declarator_2 . = initializer

    ,               reduce using rule 12 (declarator_1 -> declarator_2 .)
    ;               reduce using rule 12 (declarator_1 -> declarator_2 .)
    =               shift and go to state 30


state 26

    (26) new_type_dec -> new_type ID . { new_type_params } ;

    {               shift and go to state 31


state 27

    (32) func_def -> type ID ( . params ) { statements }
    (33) func_def -> type ID ( . ) { statements }
    (34) func_def -> type ID ( . params ) { }
    (35) func_def -> type ID ( . ) { }
    (15) declarator_2 -> ID ( . )
    (36) params -> . param , params
    (37) params -> . param
    (38) param -> . type declarator_2
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE

    )               shift and go to state 34
    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15

    type                           shift and go to state 32
    params                         shift and go to state 33
    param                          shift and go to state 35

state 28

    (16) declarator_2 -> ID [ . ]
    (17) declarator_2 -> ID [ . expression ]
    (22) expression -> . ID
    (23) expression -> . NUMBER
    (24) expression -> . CHR
    (25) expression -> . STR

    ]               shift and go to state 37
    ID              shift and go to state 36
    NUMBER          shift and go to state 39
    CHR             shift and go to state 40
    STR             shift and go to state 41

    expression                     shift and go to state 38

state 29

    (10) declarators -> declarator_1 , . declarators
    (10) declarators -> . declarator_1 , declarators
    (11) declarators -> . declarator_1
    (12) declarator_1 -> . declarator_2
    (13) declarator_1 -> . declarator_2 = initializer
    (14) declarator_2 -> . ID
    (15) declarator_2 -> . ID ( )
    (16) declarator_2 -> . ID [ ]
    (17) declarator_2 -> . ID [ expression ]

    ID              shift and go to state 43

    declarator_1                   shift and go to state 24
    declarators                    shift and go to state 42
    declarator_2                   shift and go to state 25

state 30

    (13) declarator_1 -> declarator_2 = . initializer
    (18) initializer -> . expression
    (19) initializer -> . { expressions }
    (22) expression -> . ID
    (23) expression -> . NUMBER
    (24) expression -> . CHR
    (25) expression -> . STR

    {               shift and go to state 46
    ID              shift and go to state 36
    NUMBER          shift and go to state 39
    CHR             shift and go to state 40
    STR             shift and go to state 41

    initializer                    shift and go to state 44
    expression                     shift and go to state 45

state 31

    (26) new_type_dec -> new_type ID { . new_type_params } ;
    (29) new_type_params -> . new_type_param new_type_params
    (30) new_type_params -> . new_type_param
    (31) new_type_param -> . type declarators ;
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE

    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15

    new_type_params                shift and go to state 47
    new_type_param                 shift and go to state 48
    type                           shift and go to state 49

state 32

    (38) param -> type . declarator_2
    (14) declarator_2 -> . ID
    (15) declarator_2 -> . ID ( )
    (16) declarator_2 -> . ID [ ]
    (17) declarator_2 -> . ID [ expression ]

    ID              shift and go to state 43

    declarator_2                   shift and go to state 50

state 33

    (32) func_def -> type ID ( params . ) { statements }
    (34) func_def -> type ID ( params . ) { }

    )               shift and go to state 51


state 34

    (33) func_def -> type ID ( ) . { statements }
    (35) func_def -> type ID ( ) . { }
    (15) declarator_2 -> ID ( ) .

    {               shift and go to state 52
    =               reduce using rule 15 (declarator_2 -> ID ( ) .)
    ,               reduce using rule 15 (declarator_2 -> ID ( ) .)
    ;               reduce using rule 15 (declarator_2 -> ID ( ) .)


state 35

    (36) params -> param . , params
    (37) params -> param .

    ,               shift and go to state 53
    )               reduce using rule 37 (params -> param .)


state 36

    (22) expression -> ID .

    ]               reduce using rule 22 (expression -> ID .)
    ,               reduce using rule 22 (expression -> ID .)
    ;               reduce using rule 22 (expression -> ID .)
    }               reduce using rule 22 (expression -> ID .)
    )               reduce using rule 22 (expression -> ID .)


state 37

    (16) declarator_2 -> ID [ ] .

    =               reduce using rule 16 (declarator_2 -> ID [ ] .)
    ,               reduce using rule 16 (declarator_2 -> ID [ ] .)
    ;               reduce using rule 16 (declarator_2 -> ID [ ] .)
    )               reduce using rule 16 (declarator_2 -> ID [ ] .)


state 38

    (17) declarator_2 -> ID [ expression . ]

    ]               shift and go to state 54


state 39

    (23) expression -> NUMBER .

    ]               reduce using rule 23 (expression -> NUMBER .)
    ,               reduce using rule 23 (expression -> NUMBER .)
    ;               reduce using rule 23 (expression -> NUMBER .)
    }               reduce using rule 23 (expression -> NUMBER .)
    )               reduce using rule 23 (expression -> NUMBER .)


state 40

    (24) expression -> CHR .

    ]               reduce using rule 24 (expression -> CHR .)
    ,               reduce using rule 24 (expression -> CHR .)
    ;               reduce using rule 24 (expression -> CHR .)
    }               reduce using rule 24 (expression -> CHR .)
    )               reduce using rule 24 (expression -> CHR .)


state 41

    (25) expression -> STR .

    ]               reduce using rule 25 (expression -> STR .)
    ,               reduce using rule 25 (expression -> STR .)
    ;               reduce using rule 25 (expression -> STR .)
    }               reduce using rule 25 (expression -> STR .)
    )               reduce using rule 25 (expression -> STR .)


state 42

    (10) declarators -> declarator_1 , declarators .

    ;               reduce using rule 10 (declarators -> declarator_1 , declarators .)


state 43

    (14) declarator_2 -> ID .
    (15) declarator_2 -> ID . ( )
    (16) declarator_2 -> ID . [ ]
    (17) declarator_2 -> ID . [ expression ]

    =               reduce using rule 14 (declarator_2 -> ID .)
    ,               reduce using rule 14 (declarator_2 -> ID .)
    ;               reduce using rule 14 (declarator_2 -> ID .)
    )               reduce using rule 14 (declarator_2 -> ID .)
    (               shift and go to state 55
    [               shift and go to state 28


state 44

    (13) declarator_1 -> declarator_2 = initializer .

    ,               reduce using rule 13 (declarator_1 -> declarator_2 = initializer .)
    ;               reduce using rule 13 (declarator_1 -> declarator_2 = initializer .)


state 45

    (18) initializer -> expression .

    ,               reduce using rule 18 (initializer -> expression .)
    ;               reduce using rule 18 (initializer -> expression .)


state 46

    (19) initializer -> { . expressions }
    (20) expressions -> . expression , expressions
    (21) expressions -> . expression
    (22) expression -> . ID
    (23) expression -> . NUMBER
    (24) expression -> . CHR
    (25) expression -> . STR

    ID              shift and go to state 36
    NUMBER          shift and go to state 39
    CHR             shift and go to state 40
    STR             shift and go to state 41

    expressions                    shift and go to state 56
    expression                     shift and go to state 57

state 47

    (26) new_type_dec -> new_type ID { new_type_params . } ;

    }               shift and go to state 58


state 48

    (29) new_type_params -> new_type_param . new_type_params
    (30) new_type_params -> new_type_param .
    (29) new_type_params -> . new_type_param new_type_params
    (30) new_type_params -> . new_type_param
    (31) new_type_param -> . type declarators ;
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE

    }               reduce using rule 30 (new_type_params -> new_type_param .)
    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15

    new_type_param                 shift and go to state 48
    new_type_params                shift and go to state 59
    type                           shift and go to state 49

state 49

    (31) new_type_param -> type . declarators ;
    (10) declarators -> . declarator_1 , declarators
    (11) declarators -> . declarator_1
    (12) declarator_1 -> . declarator_2
    (13) declarator_1 -> . declarator_2 = initializer
    (14) declarator_2 -> . ID
    (15) declarator_2 -> . ID ( )
    (16) declarator_2 -> . ID [ ]
    (17) declarator_2 -> . ID [ expression ]

    ID              shift and go to state 43

    declarators                    shift and go to state 60
    declarator_1                   shift and go to state 24
    declarator_2                   shift and go to state 25

state 50

    (38) param -> type declarator_2 .

    ,               reduce using rule 38 (param -> type declarator_2 .)
    )               reduce using rule 38 (param -> type declarator_2 .)


state 51

    (32) func_def -> type ID ( params ) . { statements }
    (34) func_def -> type ID ( params ) . { }

    {               shift and go to state 61


state 52

    (33) func_def -> type ID ( ) { . statements }
    (35) func_def -> type ID ( ) { . }
    (39) statements -> . statement statements
    (40) statements -> . statement
    (41) statement -> . expression ;
    (42) statement -> . decl ;
    (43) statement -> . assignment_expr ;
    (44) statement -> . conditional
    (50) statement -> . { stats_or_null }
    (22) expression -> . ID
    (23) expression -> . NUMBER
    (24) expression -> . CHR
    (25) expression -> . STR
    (8) decl -> . type declarators
    (9) decl -> . new_type_dec
    (51) assignment_expr -> . ID assignmenteq_op expression
    (45) conditional -> . IF ( expression ) { stats_or_null }
    (46) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (47) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE
    (26) new_type_dec -> . new_type ID { new_type_params } ;
    (27) new_type -> . STRUCT
    (28) new_type -> . CLASS

    }               shift and go to state 66
    {               shift and go to state 64
    ID              shift and go to state 63
    NUMBER          shift and go to state 39
    CHR             shift and go to state 40
    STR             shift and go to state 41
    IF              shift and go to state 72
    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15
    STRUCT          shift and go to state 17
    CLASS           shift and go to state 18

    type                           shift and go to state 62
    statements                     shift and go to state 65
    statement                      shift and go to state 67
    expression                     shift and go to state 68
    decl                           shift and go to state 69
    assignment_expr                shift and go to state 70
    conditional                    shift and go to state 71
    new_type_dec                   shift and go to state 8
    new_type                       shift and go to state 16

state 53

    (36) params -> param , . params
    (36) params -> . param , params
    (37) params -> . param
    (38) param -> . type declarator_2
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE

    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15

    param                          shift and go to state 35
    params                         shift and go to state 73
    type                           shift and go to state 32

state 54

    (17) declarator_2 -> ID [ expression ] .

    =               reduce using rule 17 (declarator_2 -> ID [ expression ] .)
    ,               reduce using rule 17 (declarator_2 -> ID [ expression ] .)
    ;               reduce using rule 17 (declarator_2 -> ID [ expression ] .)
    )               reduce using rule 17 (declarator_2 -> ID [ expression ] .)


state 55

    (15) declarator_2 -> ID ( . )

    )               shift and go to state 74


state 56

    (19) initializer -> { expressions . }

    }               shift and go to state 75


state 57

    (20) expressions -> expression . , expressions
    (21) expressions -> expression .

    ,               shift and go to state 76
    }               reduce using rule 21 (expressions -> expression .)


state 58

    (26) new_type_dec -> new_type ID { new_type_params } . ;

    ;               shift and go to state 77


state 59

    (29) new_type_params -> new_type_param new_type_params .

    }               reduce using rule 29 (new_type_params -> new_type_param new_type_params .)


state 60

    (31) new_type_param -> type declarators . ;

    ;               shift and go to state 78


state 61

    (32) func_def -> type ID ( params ) { . statements }
    (34) func_def -> type ID ( params ) { . }
    (39) statements -> . statement statements
    (40) statements -> . statement
    (41) statement -> . expression ;
    (42) statement -> . decl ;
    (43) statement -> . assignment_expr ;
    (44) statement -> . conditional
    (50) statement -> . { stats_or_null }
    (22) expression -> . ID
    (23) expression -> . NUMBER
    (24) expression -> . CHR
    (25) expression -> . STR
    (8) decl -> . type declarators
    (9) decl -> . new_type_dec
    (51) assignment_expr -> . ID assignmenteq_op expression
    (45) conditional -> . IF ( expression ) { stats_or_null }
    (46) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (47) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE
    (26) new_type_dec -> . new_type ID { new_type_params } ;
    (27) new_type -> . STRUCT
    (28) new_type -> . CLASS

    }               shift and go to state 80
    {               shift and go to state 64
    ID              shift and go to state 63
    NUMBER          shift and go to state 39
    CHR             shift and go to state 40
    STR             shift and go to state 41
    IF              shift and go to state 72
    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15
    STRUCT          shift and go to state 17
    CLASS           shift and go to state 18

    type                           shift and go to state 62
    statements                     shift and go to state 79
    statement                      shift and go to state 67
    expression                     shift and go to state 68
    decl                           shift and go to state 69
    assignment_expr                shift and go to state 70
    conditional                    shift and go to state 71
    new_type_dec                   shift and go to state 8
    new_type                       shift and go to state 16

state 62

    (8) decl -> type . declarators
    (10) declarators -> . declarator_1 , declarators
    (11) declarators -> . declarator_1
    (12) declarator_1 -> . declarator_2
    (13) declarator_1 -> . declarator_2 = initializer
    (14) declarator_2 -> . ID
    (15) declarator_2 -> . ID ( )
    (16) declarator_2 -> . ID [ ]
    (17) declarator_2 -> . ID [ expression ]

    ID              shift and go to state 43

    declarators                    shift and go to state 22
    declarator_1                   shift and go to state 24
    declarator_2                   shift and go to state 25

state 63

    (22) expression -> ID .
    (51) assignment_expr -> ID . assignmenteq_op expression
    (52) assignmenteq_op -> . MULTEQ
    (53) assignmenteq_op -> . ADDEQ
    (54) assignmenteq_op -> . SUBEQ
    (55) assignmenteq_op -> . MODEQ
    (56) assignmenteq_op -> . DIVEQ

    ;               reduce using rule 22 (expression -> ID .)
    MULTEQ          shift and go to state 82
    ADDEQ           shift and go to state 83
    SUBEQ           shift and go to state 84
    MODEQ           shift and go to state 85
    DIVEQ           shift and go to state 86

    assignmenteq_op                shift and go to state 81

state 64

    (50) statement -> { . stats_or_null }
    (48) stats_or_null -> . statements
    (49) stats_or_null -> . empty
    (39) statements -> . statement statements
    (40) statements -> . statement
    (64) empty -> .
    (41) statement -> . expression ;
    (42) statement -> . decl ;
    (43) statement -> . assignment_expr ;
    (44) statement -> . conditional
    (50) statement -> . { stats_or_null }
    (22) expression -> . ID
    (23) expression -> . NUMBER
    (24) expression -> . CHR
    (25) expression -> . STR
    (8) decl -> . type declarators
    (9) decl -> . new_type_dec
    (51) assignment_expr -> . ID assignmenteq_op expression
    (45) conditional -> . IF ( expression ) { stats_or_null }
    (46) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (47) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE
    (26) new_type_dec -> . new_type ID { new_type_params } ;
    (27) new_type -> . STRUCT
    (28) new_type -> . CLASS

    }               reduce using rule 64 (empty -> .)
    {               shift and go to state 64
    ID              shift and go to state 63
    NUMBER          shift and go to state 39
    CHR             shift and go to state 40
    STR             shift and go to state 41
    IF              shift and go to state 72
    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15
    STRUCT          shift and go to state 17
    CLASS           shift and go to state 18

    stats_or_null                  shift and go to state 87
    statements                     shift and go to state 88
    empty                          shift and go to state 89
    statement                      shift and go to state 67
    expression                     shift and go to state 68
    decl                           shift and go to state 69
    assignment_expr                shift and go to state 70
    conditional                    shift and go to state 71
    type                           shift and go to state 62
    new_type_dec                   shift and go to state 8
    new_type                       shift and go to state 16

state 65

    (33) func_def -> type ID ( ) { statements . }

    }               shift and go to state 90


state 66

    (35) func_def -> type ID ( ) { } .

    INCLUDE         reduce using rule 35 (func_def -> type ID ( ) { } .)
    VOID            reduce using rule 35 (func_def -> type ID ( ) { } .)
    CHAR            reduce using rule 35 (func_def -> type ID ( ) { } .)
    SHORT           reduce using rule 35 (func_def -> type ID ( ) { } .)
    INT             reduce using rule 35 (func_def -> type ID ( ) { } .)
    LONG            reduce using rule 35 (func_def -> type ID ( ) { } .)
    FLOAT           reduce using rule 35 (func_def -> type ID ( ) { } .)
    DOUBLE          reduce using rule 35 (func_def -> type ID ( ) { } .)
    STRUCT          reduce using rule 35 (func_def -> type ID ( ) { } .)
    CLASS           reduce using rule 35 (func_def -> type ID ( ) { } .)
    $end            reduce using rule 35 (func_def -> type ID ( ) { } .)


state 67

    (39) statements -> statement . statements
    (40) statements -> statement .
    (39) statements -> . statement statements
    (40) statements -> . statement
    (41) statement -> . expression ;
    (42) statement -> . decl ;
    (43) statement -> . assignment_expr ;
    (44) statement -> . conditional
    (50) statement -> . { stats_or_null }
    (22) expression -> . ID
    (23) expression -> . NUMBER
    (24) expression -> . CHR
    (25) expression -> . STR
    (8) decl -> . type declarators
    (9) decl -> . new_type_dec
    (51) assignment_expr -> . ID assignmenteq_op expression
    (45) conditional -> . IF ( expression ) { stats_or_null }
    (46) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (47) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE
    (26) new_type_dec -> . new_type ID { new_type_params } ;
    (27) new_type -> . STRUCT
    (28) new_type -> . CLASS

    }               reduce using rule 40 (statements -> statement .)
    {               shift and go to state 64
    ID              shift and go to state 63
    NUMBER          shift and go to state 39
    CHR             shift and go to state 40
    STR             shift and go to state 41
    IF              shift and go to state 72
    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15
    STRUCT          shift and go to state 17
    CLASS           shift and go to state 18

    statement                      shift and go to state 67
    statements                     shift and go to state 91
    expression                     shift and go to state 68
    decl                           shift and go to state 69
    assignment_expr                shift and go to state 70
    conditional                    shift and go to state 71
    type                           shift and go to state 62
    new_type_dec                   shift and go to state 8
    new_type                       shift and go to state 16

state 68

    (41) statement -> expression . ;

    ;               shift and go to state 92


state 69

    (42) statement -> decl . ;

    ;               shift and go to state 93


state 70

    (43) statement -> assignment_expr . ;

    ;               shift and go to state 94


state 71

    (44) statement -> conditional .

    {               reduce using rule 44 (statement -> conditional .)
    ID              reduce using rule 44 (statement -> conditional .)
    NUMBER          reduce using rule 44 (statement -> conditional .)
    CHR             reduce using rule 44 (statement -> conditional .)
    STR             reduce using rule 44 (statement -> conditional .)
    IF              reduce using rule 44 (statement -> conditional .)
    VOID            reduce using rule 44 (statement -> conditional .)
    CHAR            reduce using rule 44 (statement -> conditional .)
    SHORT           reduce using rule 44 (statement -> conditional .)
    INT             reduce using rule 44 (statement -> conditional .)
    LONG            reduce using rule 44 (statement -> conditional .)
    FLOAT           reduce using rule 44 (statement -> conditional .)
    DOUBLE          reduce using rule 44 (statement -> conditional .)
    STRUCT          reduce using rule 44 (statement -> conditional .)
    CLASS           reduce using rule 44 (statement -> conditional .)
    }               reduce using rule 44 (statement -> conditional .)


state 72

    (45) conditional -> IF . ( expression ) { stats_or_null }
    (46) conditional -> IF . ( expression ) { stats_or_null } ELSE conditional
    (47) conditional -> IF . ( expression ) { stats_or_null } ELSE { stats_or_null }

    (               shift and go to state 95


state 73

    (36) params -> param , params .

    )               reduce using rule 36 (params -> param , params .)


state 74

    (15) declarator_2 -> ID ( ) .

    =               reduce using rule 15 (declarator_2 -> ID ( ) .)
    ,               reduce using rule 15 (declarator_2 -> ID ( ) .)
    ;               reduce using rule 15 (declarator_2 -> ID ( ) .)
    )               reduce using rule 15 (declarator_2 -> ID ( ) .)


state 75

    (19) initializer -> { expressions } .

    ,               reduce using rule 19 (initializer -> { expressions } .)
    ;               reduce using rule 19 (initializer -> { expressions } .)


state 76

    (20) expressions -> expression , . expressions
    (20) expressions -> . expression , expressions
    (21) expressions -> . expression
    (22) expression -> . ID
    (23) expression -> . NUMBER
    (24) expression -> . CHR
    (25) expression -> . STR

    ID              shift and go to state 36
    NUMBER          shift and go to state 39
    CHR             shift and go to state 40
    STR             shift and go to state 41

    expression                     shift and go to state 57
    expressions                    shift and go to state 96

state 77

    (26) new_type_dec -> new_type ID { new_type_params } ; .

    ;               reduce using rule 26 (new_type_dec -> new_type ID { new_type_params } ; .)


state 78

    (31) new_type_param -> type declarators ; .

    VOID            reduce using rule 31 (new_type_param -> type declarators ; .)
    CHAR            reduce using rule 31 (new_type_param -> type declarators ; .)
    SHORT           reduce using rule 31 (new_type_param -> type declarators ; .)
    INT             reduce using rule 31 (new_type_param -> type declarators ; .)
    LONG            reduce using rule 31 (new_type_param -> type declarators ; .)
    FLOAT           reduce using rule 31 (new_type_param -> type declarators ; .)
    DOUBLE          reduce using rule 31 (new_type_param -> type declarators ; .)
    }               reduce using rule 31 (new_type_param -> type declarators ; .)


state 79

    (32) func_def -> type ID ( params ) { statements . }

    }               shift and go to state 97


state 80

    (34) func_def -> type ID ( params ) { } .

    INCLUDE         reduce using rule 34 (func_def -> type ID ( params ) { } .)
    VOID            reduce using rule 34 (func_def -> type ID ( params ) { } .)
    CHAR            reduce using rule 34 (func_def -> type ID ( params ) { } .)
    SHORT           reduce using rule 34 (func_def -> type ID ( params ) { } .)
    INT             reduce using rule 34 (func_def -> type ID ( params ) { } .)
    LONG            reduce using rule 34 (func_def -> type ID ( params ) { } .)
    FLOAT           reduce using rule 34 (func_def -> type ID ( params ) { } .)
    DOUBLE          reduce using rule 34 (func_def -> type ID ( params ) { } .)
    STRUCT          reduce using rule 34 (func_def -> type ID ( params ) { } .)
    CLASS           reduce using rule 34 (func_def -> type ID ( params ) { } .)
    $end            reduce using rule 34 (func_def -> type ID ( params ) { } .)


state 81

    (51) assignment_expr -> ID assignmenteq_op . expression
    (22) expression -> . ID
    (23) expression -> . NUMBER
    (24) expression -> . CHR
    (25) expression -> . STR

    ID              shift and go to state 36
    NUMBER          shift and go to state 39
    CHR             shift and go to state 40
    STR             shift and go to state 41

    expression                     shift and go to state 98

state 82

    (52) assignmenteq_op -> MULTEQ .

    ID              reduce using rule 52 (assignmenteq_op -> MULTEQ .)
    NUMBER          reduce using rule 52 (assignmenteq_op -> MULTEQ .)
    CHR             reduce using rule 52 (assignmenteq_op -> MULTEQ .)
    STR             reduce using rule 52 (assignmenteq_op -> MULTEQ .)


state 83

    (53) assignmenteq_op -> ADDEQ .

    ID              reduce using rule 53 (assignmenteq_op -> ADDEQ .)
    NUMBER          reduce using rule 53 (assignmenteq_op -> ADDEQ .)
    CHR             reduce using rule 53 (assignmenteq_op -> ADDEQ .)
    STR             reduce using rule 53 (assignmenteq_op -> ADDEQ .)


state 84

    (54) assignmenteq_op -> SUBEQ .

    ID              reduce using rule 54 (assignmenteq_op -> SUBEQ .)
    NUMBER          reduce using rule 54 (assignmenteq_op -> SUBEQ .)
    CHR             reduce using rule 54 (assignmenteq_op -> SUBEQ .)
    STR             reduce using rule 54 (assignmenteq_op -> SUBEQ .)


state 85

    (55) assignmenteq_op -> MODEQ .

    ID              reduce using rule 55 (assignmenteq_op -> MODEQ .)
    NUMBER          reduce using rule 55 (assignmenteq_op -> MODEQ .)
    CHR             reduce using rule 55 (assignmenteq_op -> MODEQ .)
    STR             reduce using rule 55 (assignmenteq_op -> MODEQ .)


state 86

    (56) assignmenteq_op -> DIVEQ .

    ID              reduce using rule 56 (assignmenteq_op -> DIVEQ .)
    NUMBER          reduce using rule 56 (assignmenteq_op -> DIVEQ .)
    CHR             reduce using rule 56 (assignmenteq_op -> DIVEQ .)
    STR             reduce using rule 56 (assignmenteq_op -> DIVEQ .)


state 87

    (50) statement -> { stats_or_null . }

    }               shift and go to state 99


state 88

    (48) stats_or_null -> statements .

    }               reduce using rule 48 (stats_or_null -> statements .)


state 89

    (49) stats_or_null -> empty .

    }               reduce using rule 49 (stats_or_null -> empty .)


state 90

    (33) func_def -> type ID ( ) { statements } .

    INCLUDE         reduce using rule 33 (func_def -> type ID ( ) { statements } .)
    VOID            reduce using rule 33 (func_def -> type ID ( ) { statements } .)
    CHAR            reduce using rule 33 (func_def -> type ID ( ) { statements } .)
    SHORT           reduce using rule 33 (func_def -> type ID ( ) { statements } .)
    INT             reduce using rule 33 (func_def -> type ID ( ) { statements } .)
    LONG            reduce using rule 33 (func_def -> type ID ( ) { statements } .)
    FLOAT           reduce using rule 33 (func_def -> type ID ( ) { statements } .)
    DOUBLE          reduce using rule 33 (func_def -> type ID ( ) { statements } .)
    STRUCT          reduce using rule 33 (func_def -> type ID ( ) { statements } .)
    CLASS           reduce using rule 33 (func_def -> type ID ( ) { statements } .)
    $end            reduce using rule 33 (func_def -> type ID ( ) { statements } .)


state 91

    (39) statements -> statement statements .

    }               reduce using rule 39 (statements -> statement statements .)


state 92

    (41) statement -> expression ; .

    {               reduce using rule 41 (statement -> expression ; .)
    ID              reduce using rule 41 (statement -> expression ; .)
    NUMBER          reduce using rule 41 (statement -> expression ; .)
    CHR             reduce using rule 41 (statement -> expression ; .)
    STR             reduce using rule 41 (statement -> expression ; .)
    IF              reduce using rule 41 (statement -> expression ; .)
    VOID            reduce using rule 41 (statement -> expression ; .)
    CHAR            reduce using rule 41 (statement -> expression ; .)
    SHORT           reduce using rule 41 (statement -> expression ; .)
    INT             reduce using rule 41 (statement -> expression ; .)
    LONG            reduce using rule 41 (statement -> expression ; .)
    FLOAT           reduce using rule 41 (statement -> expression ; .)
    DOUBLE          reduce using rule 41 (statement -> expression ; .)
    STRUCT          reduce using rule 41 (statement -> expression ; .)
    CLASS           reduce using rule 41 (statement -> expression ; .)
    }               reduce using rule 41 (statement -> expression ; .)


state 93

    (42) statement -> decl ; .

    {               reduce using rule 42 (statement -> decl ; .)
    ID              reduce using rule 42 (statement -> decl ; .)
    NUMBER          reduce using rule 42 (statement -> decl ; .)
    CHR             reduce using rule 42 (statement -> decl ; .)
    STR             reduce using rule 42 (statement -> decl ; .)
    IF              reduce using rule 42 (statement -> decl ; .)
    VOID            reduce using rule 42 (statement -> decl ; .)
    CHAR            reduce using rule 42 (statement -> decl ; .)
    SHORT           reduce using rule 42 (statement -> decl ; .)
    INT             reduce using rule 42 (statement -> decl ; .)
    LONG            reduce using rule 42 (statement -> decl ; .)
    FLOAT           reduce using rule 42 (statement -> decl ; .)
    DOUBLE          reduce using rule 42 (statement -> decl ; .)
    STRUCT          reduce using rule 42 (statement -> decl ; .)
    CLASS           reduce using rule 42 (statement -> decl ; .)
    }               reduce using rule 42 (statement -> decl ; .)


state 94

    (43) statement -> assignment_expr ; .

    {               reduce using rule 43 (statement -> assignment_expr ; .)
    ID              reduce using rule 43 (statement -> assignment_expr ; .)
    NUMBER          reduce using rule 43 (statement -> assignment_expr ; .)
    CHR             reduce using rule 43 (statement -> assignment_expr ; .)
    STR             reduce using rule 43 (statement -> assignment_expr ; .)
    IF              reduce using rule 43 (statement -> assignment_expr ; .)
    VOID            reduce using rule 43 (statement -> assignment_expr ; .)
    CHAR            reduce using rule 43 (statement -> assignment_expr ; .)
    SHORT           reduce using rule 43 (statement -> assignment_expr ; .)
    INT             reduce using rule 43 (statement -> assignment_expr ; .)
    LONG            reduce using rule 43 (statement -> assignment_expr ; .)
    FLOAT           reduce using rule 43 (statement -> assignment_expr ; .)
    DOUBLE          reduce using rule 43 (statement -> assignment_expr ; .)
    STRUCT          reduce using rule 43 (statement -> assignment_expr ; .)
    CLASS           reduce using rule 43 (statement -> assignment_expr ; .)
    }               reduce using rule 43 (statement -> assignment_expr ; .)


state 95

    (45) conditional -> IF ( . expression ) { stats_or_null }
    (46) conditional -> IF ( . expression ) { stats_or_null } ELSE conditional
    (47) conditional -> IF ( . expression ) { stats_or_null } ELSE { stats_or_null }
    (22) expression -> . ID
    (23) expression -> . NUMBER
    (24) expression -> . CHR
    (25) expression -> . STR

    ID              shift and go to state 36
    NUMBER          shift and go to state 39
    CHR             shift and go to state 40
    STR             shift and go to state 41

    expression                     shift and go to state 100

state 96

    (20) expressions -> expression , expressions .

    }               reduce using rule 20 (expressions -> expression , expressions .)


state 97

    (32) func_def -> type ID ( params ) { statements } .

    INCLUDE         reduce using rule 32 (func_def -> type ID ( params ) { statements } .)
    VOID            reduce using rule 32 (func_def -> type ID ( params ) { statements } .)
    CHAR            reduce using rule 32 (func_def -> type ID ( params ) { statements } .)
    SHORT           reduce using rule 32 (func_def -> type ID ( params ) { statements } .)
    INT             reduce using rule 32 (func_def -> type ID ( params ) { statements } .)
    LONG            reduce using rule 32 (func_def -> type ID ( params ) { statements } .)
    FLOAT           reduce using rule 32 (func_def -> type ID ( params ) { statements } .)
    DOUBLE          reduce using rule 32 (func_def -> type ID ( params ) { statements } .)
    STRUCT          reduce using rule 32 (func_def -> type ID ( params ) { statements } .)
    CLASS           reduce using rule 32 (func_def -> type ID ( params ) { statements } .)
    $end            reduce using rule 32 (func_def -> type ID ( params ) { statements } .)


state 98

    (51) assignment_expr -> ID assignmenteq_op expression .

    ;               reduce using rule 51 (assignment_expr -> ID assignmenteq_op expression .)


state 99

    (50) statement -> { stats_or_null } .

    {               reduce using rule 50 (statement -> { stats_or_null } .)
    ID              reduce using rule 50 (statement -> { stats_or_null } .)
    NUMBER          reduce using rule 50 (statement -> { stats_or_null } .)
    CHR             reduce using rule 50 (statement -> { stats_or_null } .)
    STR             reduce using rule 50 (statement -> { stats_or_null } .)
    IF              reduce using rule 50 (statement -> { stats_or_null } .)
    VOID            reduce using rule 50 (statement -> { stats_or_null } .)
    CHAR            reduce using rule 50 (statement -> { stats_or_null } .)
    SHORT           reduce using rule 50 (statement -> { stats_or_null } .)
    INT             reduce using rule 50 (statement -> { stats_or_null } .)
    LONG            reduce using rule 50 (statement -> { stats_or_null } .)
    FLOAT           reduce using rule 50 (statement -> { stats_or_null } .)
    DOUBLE          reduce using rule 50 (statement -> { stats_or_null } .)
    STRUCT          reduce using rule 50 (statement -> { stats_or_null } .)
    CLASS           reduce using rule 50 (statement -> { stats_or_null } .)
    }               reduce using rule 50 (statement -> { stats_or_null } .)


state 100

    (45) conditional -> IF ( expression . ) { stats_or_null }
    (46) conditional -> IF ( expression . ) { stats_or_null } ELSE conditional
    (47) conditional -> IF ( expression . ) { stats_or_null } ELSE { stats_or_null }

    )               shift and go to state 101


state 101

    (45) conditional -> IF ( expression ) . { stats_or_null }
    (46) conditional -> IF ( expression ) . { stats_or_null } ELSE conditional
    (47) conditional -> IF ( expression ) . { stats_or_null } ELSE { stats_or_null }

    {               shift and go to state 102


state 102

    (45) conditional -> IF ( expression ) { . stats_or_null }
    (46) conditional -> IF ( expression ) { . stats_or_null } ELSE conditional
    (47) conditional -> IF ( expression ) { . stats_or_null } ELSE { stats_or_null }
    (48) stats_or_null -> . statements
    (49) stats_or_null -> . empty
    (39) statements -> . statement statements
    (40) statements -> . statement
    (64) empty -> .
    (41) statement -> . expression ;
    (42) statement -> . decl ;
    (43) statement -> . assignment_expr ;
    (44) statement -> . conditional
    (50) statement -> . { stats_or_null }
    (22) expression -> . ID
    (23) expression -> . NUMBER
    (24) expression -> . CHR
    (25) expression -> . STR
    (8) decl -> . type declarators
    (9) decl -> . new_type_dec
    (51) assignment_expr -> . ID assignmenteq_op expression
    (45) conditional -> . IF ( expression ) { stats_or_null }
    (46) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (47) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE
    (26) new_type_dec -> . new_type ID { new_type_params } ;
    (27) new_type -> . STRUCT
    (28) new_type -> . CLASS

    }               reduce using rule 64 (empty -> .)
    {               shift and go to state 64
    ID              shift and go to state 63
    NUMBER          shift and go to state 39
    CHR             shift and go to state 40
    STR             shift and go to state 41
    IF              shift and go to state 72
    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15
    STRUCT          shift and go to state 17
    CLASS           shift and go to state 18

    expression                     shift and go to state 68
    stats_or_null                  shift and go to state 103
    conditional                    shift and go to state 71
    statements                     shift and go to state 88
    empty                          shift and go to state 89
    statement                      shift and go to state 67
    decl                           shift and go to state 69
    assignment_expr                shift and go to state 70
    type                           shift and go to state 62
    new_type_dec                   shift and go to state 8
    new_type                       shift and go to state 16

state 103

    (45) conditional -> IF ( expression ) { stats_or_null . }
    (46) conditional -> IF ( expression ) { stats_or_null . } ELSE conditional
    (47) conditional -> IF ( expression ) { stats_or_null . } ELSE { stats_or_null }

    }               shift and go to state 104


state 104

    (45) conditional -> IF ( expression ) { stats_or_null } .
    (46) conditional -> IF ( expression ) { stats_or_null } . ELSE conditional
    (47) conditional -> IF ( expression ) { stats_or_null } . ELSE { stats_or_null }

    {               reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    ID              reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    NUMBER          reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    CHR             reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    STR             reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    IF              reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    VOID            reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    CHAR            reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    SHORT           reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    INT             reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    LONG            reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    FLOAT           reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    DOUBLE          reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    STRUCT          reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    CLASS           reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    }               reduce using rule 45 (conditional -> IF ( expression ) { stats_or_null } .)
    ELSE            shift and go to state 105


state 105

    (46) conditional -> IF ( expression ) { stats_or_null } ELSE . conditional
    (47) conditional -> IF ( expression ) { stats_or_null } ELSE . { stats_or_null }
    (45) conditional -> . IF ( expression ) { stats_or_null }
    (46) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (47) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }

    {               shift and go to state 106
    IF              shift and go to state 72

    conditional                    shift and go to state 107

state 106

    (47) conditional -> IF ( expression ) { stats_or_null } ELSE { . stats_or_null }
    (48) stats_or_null -> . statements
    (49) stats_or_null -> . empty
    (39) statements -> . statement statements
    (40) statements -> . statement
    (64) empty -> .
    (41) statement -> . expression ;
    (42) statement -> . decl ;
    (43) statement -> . assignment_expr ;
    (44) statement -> . conditional
    (50) statement -> . { stats_or_null }
    (22) expression -> . ID
    (23) expression -> . NUMBER
    (24) expression -> . CHR
    (25) expression -> . STR
    (8) decl -> . type declarators
    (9) decl -> . new_type_dec
    (51) assignment_expr -> . ID assignmenteq_op expression
    (45) conditional -> . IF ( expression ) { stats_or_null }
    (46) conditional -> . IF ( expression ) { stats_or_null } ELSE conditional
    (47) conditional -> . IF ( expression ) { stats_or_null } ELSE { stats_or_null }
    (57) type -> . VOID
    (58) type -> . CHAR
    (59) type -> . SHORT
    (60) type -> . INT
    (61) type -> . LONG
    (62) type -> . FLOAT
    (63) type -> . DOUBLE
    (26) new_type_dec -> . new_type ID { new_type_params } ;
    (27) new_type -> . STRUCT
    (28) new_type -> . CLASS

    }               reduce using rule 64 (empty -> .)
    {               shift and go to state 64
    ID              shift and go to state 63
    NUMBER          shift and go to state 39
    CHR             shift and go to state 40
    STR             shift and go to state 41
    IF              shift and go to state 72
    VOID            shift and go to state 9
    CHAR            shift and go to state 10
    SHORT           shift and go to state 11
    INT             shift and go to state 12
    LONG            shift and go to state 13
    FLOAT           shift and go to state 14
    DOUBLE          shift and go to state 15
    STRUCT          shift and go to state 17
    CLASS           shift and go to state 18

    expression                     shift and go to state 68
    stats_or_null                  shift and go to state 108
    statements                     shift and go to state 88
    empty                          shift and go to state 89
    statement                      shift and go to state 67
    decl                           shift and go to state 69
    assignment_expr                shift and go to state 70
    conditional                    shift and go to state 71
    type                           shift and go to state 62
    new_type_dec                   shift and go to state 8
    new_type                       shift and go to state 16

state 107

    (46) conditional -> IF ( expression ) { stats_or_null } ELSE conditional .

    {               reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    ID              reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    NUMBER          reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    CHR             reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    STR             reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    IF              reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    VOID            reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    CHAR            reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    SHORT           reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    INT             reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    LONG            reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    FLOAT           reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    DOUBLE          reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    STRUCT          reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    CLASS           reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)
    }               reduce using rule 46 (conditional -> IF ( expression ) { stats_or_null } ELSE conditional .)


state 108

    (47) conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null . }

    }               shift and go to state 109


state 109

    (47) conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .

    {               reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    ID              reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    NUMBER          reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    CHR             reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    STR             reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    IF              reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    VOID            reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    CHAR            reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    SHORT           reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    INT             reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    LONG            reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    FLOAT           reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    DOUBLE          reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    STRUCT          reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    CLASS           reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)
    }               reduce using rule 47 (conditional -> IF ( expression ) { stats_or_null } ELSE { stats_or_null } .)

